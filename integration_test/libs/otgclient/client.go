// Package otgclient provides primitives to interact the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen DO NOT EDIT.
package otgclient

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)

// Bgpv4Metric defines model for Bgpv4.Metric.
type Bgpv4Metric struct {

	// The name of a configured BGPv4 device.
	Name *string `json:"name,omitempty"`

	// Number of advertised routes sent
	RoutesAdvertised *int `json:"routes_advertised,omitempty"`

	// Number of routes withdrawn
	RoutesWithdrawn *int `json:"routes_withdrawn,omitempty"`

	// Sessions are not active state
	SessionsDown *int `json:"sessions_down,omitempty"`

	// Sessions not able to start due to some internal issue
	SessionsNotStarted *int `json:"sessions_not_started,omitempty"`

	// Total number of session
	SessionsTotal *int `json:"sessions_total,omitempty"`

	// Sessions are in active state
	SessionsUp *int `json:"sessions_up,omitempty"`
}

// Bgpv4MetricsRequest defines model for Bgpv4.Metrics.Request.
type Bgpv4MetricsRequest struct {

	// The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the BGPv4 device cannot be excluded.
	ColumnNames *[]string `json:"column_names,omitempty"`

	// The names of BGPv4 device to return results for. An empty list will return results for all BGPv4 devices.
	DeviceNames *[]string `json:"device_names,omitempty"`
}

// Bgpv6Metric defines model for Bgpv6.Metric.
type Bgpv6Metric struct {

	// The name of a configured BGPv6 device.
	Name *string `json:"name,omitempty"`

	// Number of advertised routes sent
	RoutesAdvertised *int `json:"routes_advertised,omitempty"`

	// Number of routes withdrawn
	RoutesWithdrawn *int `json:"routes_withdrawn,omitempty"`

	// Sessions are not active state
	SessionsDown *int `json:"sessions_down,omitempty"`

	// Sessions not started yet or sessions not able to start due to some internal issue
	SessionsNotStarted *int `json:"sessions_not_started,omitempty"`

	// Total number of session
	SessionsTotal *int `json:"sessions_total,omitempty"`

	// Sessions are in active state
	SessionsUp *int `json:"sessions_up,omitempty"`
}

// Bgpv6MetricsRequest defines model for Bgpv6.Metrics.Request.
type Bgpv6MetricsRequest struct {

	// The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the BGPv6 device cannot be excluded.
	ColumnNames *[]string `json:"column_names,omitempty"`

	// The names of BGPv6 device to return results for. An empty list will return results for all BGPv6 devices.
	DeviceNames *[]string `json:"device_names,omitempty"`
}

// Capabilities defines model for Capabilities.
type Capabilities struct {

	// A /components/schemas/... path and specific format  details regarding the path. Specific model format details can be additional objects and properties represented as a hashmap. For example layer1 models are defined as a hashmap key to object with  each object consisting of a specific name/value property pairs. This list of items will detail any specific formats, properties, enums.
	Formats *[]string `json:"formats,omitempty"`

	// A list of /components/schemas/... paths that are not supported.
	Unsupported *[]string `json:"unsupported,omitempty"`
}

// Capture defines model for Capture.
type Capture struct {

	// A list of filters to apply to the capturing ports. If no filters are specified then all packets will be captured. A capture can have multiple filters. The number of filters supported is determined by the implementation which can be retrieved using the capabilities API.
	// When multiple filters are specified the capture implementation  must && (and) all the filters.
	Filters *[]CaptureFilter `json:"filters,omitempty"`

	// The format of the capture file.
	Format *string `json:"format,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// Overwrite the capture buffer.
	Overwrite *bool `json:"overwrite,omitempty"`

	// The maximum size of each captured packet. If no value is specified or it is null then the entire packet will be captured.
	PacketSize *int `json:"packet_size,omitempty"`

	// The unique names of ports that the capture settings will apply to. Port_names cannot be duplicated between capture objects.
	PortNames *[]string `json:"port_names,omitempty"`
}

// CaptureCustom defines model for Capture.Custom.
type CaptureCustom struct {
	Mask   *string `json:"mask,omitempty"`
	Negate *bool   `json:"negate,omitempty"`

	// The byte offset to filter on
	Offset *int    `json:"offset,omitempty"`
	Value  *string `json:"value,omitempty"`
}

// CaptureEthernet defines model for Capture.Ethernet.
type CaptureEthernet struct {
	Dst       *CaptureField `json:"dst,omitempty"`
	EtherType *CaptureField `json:"ether_type,omitempty"`
	PfcQueue  *CaptureField `json:"pfc_queue,omitempty"`
	Src       *CaptureField `json:"src,omitempty"`
}

// CaptureField defines model for Capture.Field.
type CaptureField struct {
	Mask   *string `json:"mask,omitempty"`
	Negate *bool   `json:"negate,omitempty"`
	Value  *string `json:"value,omitempty"`
}

// CaptureFilter defines model for Capture.Filter.
type CaptureFilter struct {
	Choice   string           `json:"choice"`
	Custom   *CaptureCustom   `json:"custom,omitempty"`
	Ethernet *CaptureEthernet `json:"ethernet,omitempty"`
	Ipv4     *CaptureIpv4     `json:"ipv4,omitempty"`
	Vlan     *CaptureVlan     `json:"vlan,omitempty"`
}

// CaptureIpv4 defines model for Capture.Ipv4.
type CaptureIpv4 struct {
	DontFragment   *CaptureField `json:"dont_fragment,omitempty"`
	Dst            *CaptureField `json:"dst,omitempty"`
	FragmentOffset *CaptureField `json:"fragment_offset,omitempty"`
	HeadeerLength  *CaptureField `json:"headeer_length,omitempty"`
	HeaderChecksum *CaptureField `json:"header_checksum,omitempty"`
	Identification *CaptureField `json:"identification,omitempty"`
	MoreFragments  *CaptureField `json:"more_fragments,omitempty"`
	Priority       *CaptureField `json:"priority,omitempty"`
	Protocol       *CaptureField `json:"protocol,omitempty"`
	Reserved       *CaptureField `json:"reserved,omitempty"`
	Src            *CaptureField `json:"src,omitempty"`
	TimeToLive     *CaptureField `json:"time_to_live,omitempty"`
	TotalLength    *CaptureField `json:"total_length,omitempty"`
	Version        *CaptureField `json:"version,omitempty"`
}

// CaptureRequest defines model for Capture.Request.
type CaptureRequest struct {

	// The name of a port a capture is started on.
	PortName string `json:"port_name"`
}

// CaptureState defines model for Capture.State.
type CaptureState struct {

	// The name of ports to start capturing packets on. An empty or null list will control all port objects.
	PortNames *[]string `json:"port_names,omitempty"`

	// The capture state.
	State string `json:"state"`
}

// CaptureVlan defines model for Capture.Vlan.
type CaptureVlan struct {
	Cfi      *CaptureField `json:"cfi,omitempty"`
	Id       *CaptureField `json:"id,omitempty"`
	Priority *CaptureField `json:"priority,omitempty"`
	Protocol *CaptureField `json:"protocol,omitempty"`
}

// Config defines model for Config.
type Config struct {

	// The capture settings that will be configured on the traffic generator.
	Captures *[]Capture `json:"captures,omitempty"`

	// The emulated device settings that will be configured on the traffic generator.
	Devices *[]Device `json:"devices,omitempty"`

	// The flows that will be configured on the traffic generator.
	Flows *[]Flow `json:"flows,omitempty"`

	// The lags that will be configured on the traffic generator.
	Lags *[]Lag `json:"lags,omitempty"`

	// The layer1 settings that will be configured on the traffic generator.
	Layer1 *[]Layer1 `json:"layer1,omitempty"`

	// Global configuration options.
	Options *ConfigOptions `json:"options,omitempty"`

	// The ports that will be configured on the traffic generator.
	Ports *[]Port `json:"ports,omitempty"`
}

// ConfigOptions defines model for Config.Options.
type ConfigOptions struct {

	// Common port options that apply to all configured Port objects.
	PortOptions *PortOptions `json:"port_options,omitempty"`
}

// Device defines model for Device.
type Device struct {

	// The unique name of a Port or Lag object that will contain the  emulated interfaces and/or protocol devices.
	ContainerName string `json:"container_name"`

	// An ethernet interface with an IPv4 and IPv6 interface stack
	// Base ethernet interface
	Ethernet DeviceEthernet `json:"ethernet"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`
}

// DeviceBgpAddPath defines model for Device.BgpAddPath.
type DeviceBgpAddPath struct {

	// The id of the additional path.
	PathId *int `json:"path_id,omitempty"`
}

// DeviceBgpAdvanced defines model for Device.BgpAdvanced.
type DeviceBgpAdvanced struct {

	// Number of seconds the sender proposes for the value of the Hold Timer
	HoldTimeInterval *int `json:"hold_time_interval,omitempty"`

	// Number of seconds between transmissions of Keep Alive messages by router
	KeepAliveInterval *int `json:"keep_alive_interval,omitempty"`

	// The value to be used as a secret MD5 key for authentication. If null or an empty string then authentication will not be enabled.
	Md5Key *string `json:"md5_key"`

	// The limited number of iterations that a unit of data can experience before the data is discarded. This is placed in the TTL field in the IP header of the  transmitted packets.
	TimeToLive *int `json:"time_to_live,omitempty"`

	// The time interval at which UPDATE messages are sent to the DUT, expressed as the number of milliseconds between UPDATE messages.
	UpdateInterval *int `json:"update_interval,omitempty"`
}

// DeviceBgpAsPath defines model for Device.BgpAsPath.
type DeviceBgpAsPath struct {

	// The AS path segments (non random) per route range
	AsPathSegments *[]DeviceBgpAsPathSegment `json:"as_path_segments,omitempty"`

	// TBD
	AsSetMode *string `json:"as_set_mode,omitempty"`

	// TBD
	OverridePeerAsSetMode *bool `json:"override_peer_as_set_mode,omitempty"`
}

// DeviceBgpAsPathSegment defines model for Device.BgpAsPathSegment.
type DeviceBgpAsPathSegment struct {

	// The AS numbers in this AS path segment.
	AsNumbers *[]int `json:"as_numbers,omitempty"`

	// AS sequence is the most common type of AS_PATH, it contains the  list of ASNs starting with the most recent ASN being added read  from left to right.
	// The other three AS_PATH types are used for Confederations - AS_SET is the type of AS_PATH attribute that summarizes routes using using the aggregate-address command, allowing AS_PATHs to be  summarized in the update as well. - AS_CONFED_SEQ gives the list of ASNs in the path starting with the  most recent ASN to be added reading left to right - AS_CONFED_SET will allow summarization of multiple AS PATHs to be  sent in BGP Updates.
	SegmentType *string `json:"segment_type,omitempty"`
}

// DeviceBgpBindingSubTlv defines model for Device.BgpBindingSubTlv.
type DeviceBgpBindingSubTlv struct {

	// TBD
	BindingSidType *string `json:"binding_sid_type,omitempty"`

	// Only valid if binding_sid_type is four_octet_sid
	BsidAsMplsLabel *bool `json:"bsid_as_mpls_label,omitempty"`

	// TBD
	FourOctetSid *int `json:"four_octet_sid,omitempty"`

	// TBD
	IFlag *bool `json:"i_flag,omitempty"`

	// Only valid if binding_sid_type is ipv6_sid
	Ipv6Sid *string `json:"ipv6_sid,omitempty"`

	// TBD
	RemainingFlagBits *int `json:"remaining_flag_bits,omitempty"`

	// TBD
	SFlag *bool `json:"s_flag,omitempty"`
}

// DeviceBgpCapability defines model for Device.BgpCapability.
type DeviceBgpCapability struct {

	// TBD
	Evpn *bool `json:"evpn,omitempty"`

	// TBD
	ExtendedNextHopEncoding *bool `json:"extended_next_hop_encoding,omitempty"`

	// TBD
	Ipv4Mdt *bool `json:"ipv4_mdt,omitempty"`

	// TBD
	Ipv4MplsVpn *bool `json:"ipv4_mpls_vpn,omitempty"`

	// TBD
	Ipv4Multicast *bool `json:"ipv4_multicast,omitempty"`

	// TBD
	Ipv4MulticastMplsVpn *bool `json:"ipv4_multicast_mpls_vpn,omitempty"`

	// TBD
	Ipv4MulticastVpn *bool `json:"ipv4_multicast_vpn,omitempty"`

	// TBD
	Ipv4SrTePolicy *bool `json:"ipv4_sr_te_policy,omitempty"`

	// TBD
	Ipv4Unicast *bool `json:"ipv4_unicast,omitempty"`

	// TBD
	Ipv4UnicastAddPath *bool `json:"ipv4_unicast_add_path,omitempty"`

	// TBD
	Ipv4UnicastFlowSpec *bool `json:"ipv4_unicast_flow_spec,omitempty"`

	// TBD
	Ipv6Mdt *bool `json:"ipv6_mdt,omitempty"`

	// TBD
	Ipv6MplsVpn *bool `json:"ipv6_mpls_vpn,omitempty"`

	// TBD
	Ipv6Multicast *bool `json:"ipv6_multicast,omitempty"`

	// TBD
	Ipv6MulticastMplsVpn *bool `json:"ipv6_multicast_mpls_vpn,omitempty"`

	// TBD
	Ipv6MulticastVpn *bool `json:"ipv6_multicast_vpn,omitempty"`

	// TBD
	Ipv6SrTePolicy *bool `json:"ipv6_sr_te_policy,omitempty"`

	// TBD
	Ipv6Unicast *bool `json:"ipv6_unicast,omitempty"`

	// TBD
	Ipv6UnicastAddPath *bool `json:"ipv6_unicast_add_path,omitempty"`

	// TBD
	Ipv6UnicastFlowSpec *bool `json:"ipv6_unicast_flow_spec,omitempty"`

	// TBD
	LinkStateNonVpn *bool `json:"link_state_non_vpn,omitempty"`

	// TBD
	LinkStateVpn *bool `json:"link_state_vpn,omitempty"`

	// TBD
	RouteConstraint *bool `json:"route_constraint,omitempty"`

	// TBD
	RouteRefresh *bool `json:"route_refresh,omitempty"`

	// TBD
	Vpls *bool `json:"vpls,omitempty"`
}

// DeviceBgpCommunity defines model for Device.BgpCommunity.
type DeviceBgpCommunity struct {

	// Last two octets of the community AS number
	AsCustom *int `json:"as_custom,omitempty"`

	// First two octets of 32 bit community AS number
	AsNumber *int `json:"as_number,omitempty"`

	// The type of community AS number.
	CommunityType *string `json:"community_type,omitempty"`
}

// DeviceBgpExplicitNullLabelPolicySubTlv defines model for Device.BgpExplicitNullLabelPolicySubTlv.
type DeviceBgpExplicitNullLabelPolicySubTlv struct {

	// The value of the explicit null label policy
	ExplicitNullLabelPolicy *string `json:"explicit_null_label_policy,omitempty"`
}

// DeviceBgpPreferenceSubTlv defines model for Device.BgpPreferenceSubTlv.
type DeviceBgpPreferenceSubTlv struct {

	// TBD
	Preference *int `json:"preference,omitempty"`
}

// DeviceBgpRemoteEndpointSubTlv defines model for Device.BgpRemoteEndpointSubTlv.
type DeviceBgpRemoteEndpointSubTlv struct {

	// Determines the address type
	AddressFamily *string `json:"address_family,omitempty"`

	// Autonomous system (AS) number
	AsNumber *int `json:"as_number,omitempty"`

	// The IPv4 address
	Ipv4Address *string `json:"ipv4_address,omitempty"`

	// The IPv6 address
	Ipv6Address *string `json:"ipv6_address,omitempty"`
}

// DeviceBgpRouteAdvanced defines model for Device.BgpRouteAdvanced.
type DeviceBgpRouteAdvanced struct {

	// The multi exit discriminator (MED) value.  A null value means the MED feature is not enabled.
	MultiExitDiscriminator *int `json:"multi_exit_discriminator"`

	// The origin value.  A null value means the origin feature is not enabled.
	Origin *string `json:"origin"`
}

// DeviceBgpSegment defines model for Device.BgpSegment.
type DeviceBgpSegment struct {

	// If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer.  If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.
	Active *bool `json:"active,omitempty"`

	// TBD
	Ipv6Sid *string `json:"ipv6_sid,omitempty"`

	// MPLS label
	MplsLabel *int `json:"mpls_label,omitempty"`

	// TBD
	MplsTc *int `json:"mpls_tc,omitempty"`

	// TBD
	MplsTtl *int `json:"mpls_ttl,omitempty"`

	// TBD
	RemainingFlagBits *int `json:"remaining_flag_bits,omitempty"`

	// TBD
	SegmentType *string `json:"segment_type,omitempty"`

	// TBD
	VFlag *bool `json:"v_flag,omitempty"`
}

// DeviceBgpSegmentList defines model for Device.BgpSegmentList.
type DeviceBgpSegmentList struct {

	// If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer.  If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.
	Active *bool `json:"active,omitempty"`

	// The weight associated with a given path.
	SegmentWeight *int                `json:"segment_weight,omitempty"`
	Segments      *[]DeviceBgpSegment `json:"segments,omitempty"`
}

// DeviceBgpSrTePolicy defines model for Device.BgpSrTePolicy.
type DeviceBgpSrTePolicy struct {

	// The BGP Additional Paths feature is a BGP extension that allows the  advertisement of multiple paths for the same prefix without the new  paths implicitly replacing any previous paths.
	AddPath *DeviceBgpAddPath `json:"add_path,omitempty"`

	// Autonomous Systems (AS) numbers that a route passes through to reach  the destination
	AsPath *DeviceBgpAsPath `json:"as_path,omitempty"`

	// Identifies the policy. It is used to match the color of the  destination prefixes to steer traffic into the SR Policy.
	Color *int `json:"color,omitempty"`

	// Optional community settings
	Communities *[]DeviceBgpCommunity `json:"communities,omitempty"`

	// Identifies the policy in the context of (color and endpoint) tuple.  It is used by the SR Policy originator to make unique multiple  occurrences of the same SR Policy.
	Distinguisher *int `json:"distinguisher,omitempty"`

	// Specifies a single node or a set of nodes. It is selected on the basis of the policy_type (AFI).
	Ipv4Endpoint *string `json:"ipv4_endpoint,omitempty"`

	// Specifies a single node or a set of nodes. It is selected on the basis of the policy_type (AFI).
	Ipv6Endpoint *string `json:"ipv6_endpoint,omitempty"`

	// Optional container for BGP SR TE Policy next hop settings.
	NextHop *DeviceBgpSrTePolicyNextHop `json:"next_hop,omitempty"`

	// Address family indicator (AFI).
	PolicyType *string `json:"policy_type,omitempty"`

	// Optional tunnel TLV settings
	TunnelTlvs *[]DeviceBgpTunnelTlv `json:"tunnel_tlvs,omitempty"`
}

// DeviceBgpSrTePolicyNextHop defines model for Device.BgpSrTePolicyNextHop.
type DeviceBgpSrTePolicyNextHop struct {

	// The IPv4 address of the next hop if the next_hop_mode is manual and the next_hop_address_type is IPv4.
	Ipv4Address *string `json:"ipv4_address,omitempty"`

	// The IPv6 address of the next hop if the next_hop_mode is manual and the next_hop_address_type is IPv6.
	Ipv6Address *string `json:"ipv6_address,omitempty"`

	// TBD
	NextHopAddressType *string `json:"next_hop_address_type,omitempty"`

	// TBD
	NextHopMode *string `json:"next_hop_mode,omitempty"`
}

// DeviceBgpTunnelTlv defines model for Device.BgpTunnelTlv.
type DeviceBgpTunnelTlv struct {

	// If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer.  If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.
	Active *bool `json:"active,omitempty"`

	// Container for BGP binding sub TLV settings.
	BindingSubTlv *DeviceBgpBindingSubTlv `json:"binding_sub_tlv,omitempty"`

	// Container for BGP explicit null label policy sub TLV settings.
	ExplicitNullLabelPolicySubTlv *DeviceBgpExplicitNullLabelPolicySubTlv `json:"explicit_null_label_policy_sub_tlv,omitempty"`

	// Container for BGP preference sub TLV settings.
	PreferenceSubTlv *DeviceBgpPreferenceSubTlv `json:"preference_sub_tlv,omitempty"`

	// Container for BGP remote endpoint sub TLV settings.
	RemoteEndpointSubTlv *DeviceBgpRemoteEndpointSubTlv `json:"remote_endpoint_sub_tlv,omitempty"`
	SegmentLists         *[]DeviceBgpSegmentList        `json:"segment_lists,omitempty"`
}

// DeviceBgpv4 defines model for Device.Bgpv4.
type DeviceBgpv4 struct {

	// If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer.  If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.
	Active *bool `json:"active,omitempty"`

	// Container for BGP advanced settings.
	Advanced *DeviceBgpAdvanced `json:"advanced,omitempty"`

	// Autonomous System Number (AS number or ASN)
	AsNumber *int `json:"as_number,omitempty"`

	// The AS number set mode
	AsNumberSetMode *string `json:"as_number_set_mode,omitempty"`

	// The width in bytes of the as_number values. Any as_number values that exceed the width MUST result in an error
	AsNumberWidth *string `json:"as_number_width,omitempty"`

	// The type of BGP autonomous system. External BGP is used for BGP links between two or more autonomous systems (ebgp) Internal BGP is used within a single autonomous system (ibgp). BGP property defaults are aligned with this object defined as an internal BGP peer. If the as_type is specified as ebgp then other properties will need to be specified according an external BGP peer.
	AsType *string `json:"as_type,omitempty"`

	// Emulated BGPv4 routes
	Bgpv4Routes *[]DeviceBgpv4Route `json:"bgpv4_routes,omitempty"`

	// Emulated BGPv6 routes
	Bgpv6Routes *[]DeviceBgpv6Route `json:"bgpv6_routes,omitempty"`

	// Container for BGP capability settings.
	Capability *DeviceBgpCapability `json:"capability,omitempty"`

	// IPv4 address of the BGP peer for the session
	DutAddress *string `json:"dut_address,omitempty"`

	// Local IPv4 address of the emulated router
	LocalAddress *string `json:"local_address,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// The BGP router ID is a unique identifier used by routing protocols. It is a 32-bit value that is often represented by an IPv4 address.
	RouterId *string `json:"router_id,omitempty"`

	// Segment routing/traffic engineering policies
	SrTePolicies *[]DeviceBgpSrTePolicy `json:"sr_te_policies,omitempty"`
}

// DeviceBgpv4Route defines model for Device.Bgpv4Route.
type DeviceBgpv4Route struct {

	// The BGP Additional Paths feature is a BGP extension that allows the  advertisement of multiple paths for the same prefix without the new  paths implicitly replacing any previous paths.
	AddPath *DeviceBgpAddPath `json:"add_path,omitempty"`

	// A list of symmetrical or asymmetrical route addresses
	Addresses *[]DeviceBgpv4RouteAddress `json:"addresses,omitempty"`

	// Container for advanced BGP route range settings
	Advanced *DeviceBgpRouteAdvanced `json:"advanced,omitempty"`

	// Autonomous Systems (AS) numbers that a route passes through to reach  the destination
	AsPath *DeviceBgpAsPath `json:"as_path,omitempty"`

	// Optional community settings.
	Communities *[]DeviceBgpCommunity `json:"communities,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// IP Address of next router to forward a packet to its final destination
	NextHopAddress *string `json:"next_hop_address,omitempty"`
}

// DeviceBgpv4RouteAddress defines model for Device.Bgpv4RouteAddress.
type DeviceBgpv4RouteAddress struct {

	// The starting address of the network
	Address *string `json:"address,omitempty"`

	// The total number of addresses in the range
	Count *string `json:"count,omitempty"`

	// The IPv4 network prefix to be applied to the address.
	Prefix *int `json:"prefix,omitempty"`

	// The amount to increase each address by
	Step *string `json:"step,omitempty"`
}

// DeviceBgpv6 defines model for Device.Bgpv6.
type DeviceBgpv6 struct {

	// If enabled means that this part of the configuration including any active 'children' nodes will be advertised to peer.  If disabled, this means that though config is present, it is not taking any part of the test but can be activated at run-time to advertise just this part of the configuration to the peer.
	Active *bool `json:"active,omitempty"`

	// Container for BGP advanced settings.
	Advanced *DeviceBgpAdvanced `json:"advanced,omitempty"`

	// Autonomous System Number (AS number or ASN)
	AsNumber *int `json:"as_number,omitempty"`

	// The AS number set mode
	AsNumberSetMode *string `json:"as_number_set_mode,omitempty"`

	// The width in bytes of the as_number values. Any as_number values that exceed the width MUST result in an error
	AsNumberWidth *string `json:"as_number_width,omitempty"`

	// The type of BGP autonomous system. External BGP is used for BGP links between two or more autonomous systems (ebgp) Internal BGP is used within a single autonomous system (ibgp). BGP property defaults are aligned with this object defined as an internal BGP peer. If the as_type is specified as ebgp then other properties will need to be specified according an external BGP peer.
	AsType *string `json:"as_type,omitempty"`

	// Emulated BGPv4 routes
	Bgpv4Routes *[]DeviceBgpv4Route `json:"bgpv4_routes,omitempty"`

	// Emulated BGPv6 routes
	Bgpv6Routes *[]DeviceBgpv6Route `json:"bgpv6_routes,omitempty"`

	// Container for BGP capability settings.
	Capability *DeviceBgpCapability `json:"capability,omitempty"`

	// IPv6 address of the BGP peer for the session
	DutAddress *string `json:"dut_address,omitempty"`

	// Local IPv6 address of the emulated router
	LocalAddress *string `json:"local_address,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// The BGP router ID is a unique identifier used by routing protocols. It is a 32-bit value that is often represented by an IPv4 address.
	RouterId *string `json:"router_id,omitempty"`

	// Container for BGPv6 segment routing settings.
	SegmentRouting *DeviceBgpv6SegmentRouting `json:"segment_routing,omitempty"`

	// Segment routing/traffic engineering policies
	SrTePolicies *[]DeviceBgpSrTePolicy `json:"sr_te_policies,omitempty"`
}

// DeviceBgpv6Route defines model for Device.Bgpv6Route.
type DeviceBgpv6Route struct {

	// The BGP Additional Paths feature is a BGP extension that allows the  advertisement of multiple paths for the same prefix without the new  paths implicitly replacing any previous paths.
	AddPath *DeviceBgpAddPath `json:"add_path,omitempty"`

	// A list of symmetrical or asymmetrical route addresses
	Addresses *[]DeviceBgpv6RouteAddress `json:"addresses,omitempty"`

	// Container for advanced BGP route range settings
	Advanced *DeviceBgpRouteAdvanced `json:"advanced,omitempty"`

	// Autonomous Systems (AS) numbers that a route passes through to reach  the destination
	AsPath *DeviceBgpAsPath `json:"as_path,omitempty"`

	// Optional community settings.
	Communities *[]DeviceBgpCommunity `json:"communities,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// IP Address of next router to forward a packet to its final destination
	NextHopAddress *string `json:"next_hop_address,omitempty"`
}

// DeviceBgpv6RouteAddress defines model for Device.Bgpv6RouteAddress.
type DeviceBgpv6RouteAddress struct {

	// The starting address of the network
	Address *string `json:"address,omitempty"`

	// The total number of addresses in the range
	Count *string `json:"count,omitempty"`

	// The IPv6 network prefix to be applied to the address
	Prefix *int `json:"prefix,omitempty"`

	// The amount to increase each address by
	Step *string `json:"step,omitempty"`
}

// DeviceBgpv6SegmentRouting defines model for Device.Bgpv6SegmentRouting.
type DeviceBgpv6SegmentRouting struct {

	// TBD
	AdvertiseSrTePolicy *bool `json:"advertise_sr_te_policy,omitempty"`

	// TBD
	AutoGenerateSegmentLeftValue *bool `json:"auto_generate_segment_left_value,omitempty"`

	// TBD
	CopyTimeToLive *bool `json:"copy_time_to_live,omitempty"`

	// TBD
	IngressSupportsVpn *bool `json:"ingress_supports_vpn,omitempty"`

	// TBD
	MaxSidsPerSrh *int `json:"max_sids_per_srh,omitempty"`

	// TBD
	ReducedEncapsulation *bool `json:"reduced_encapsulation,omitempty"`

	// TBD
	SegmentLeftValue *int `json:"segment_left_value,omitempty"`

	// TBD
	TimeToLive *int `json:"time_to_live,omitempty"`
}

// DeviceEthernet defines model for Device.Ethernet.
type DeviceEthernet struct {

	// An IPv4 interface with gateway
	// A base IPv4 interface
	Ipv4 *DeviceIpv4 `json:"ipv4,omitempty"`

	// An IPv6 interface with gateway
	// A base IPv6 interface
	Ipv6 *DeviceIpv6 `json:"ipv6,omitempty"`

	// Media access control address
	Mac *string `json:"mac,omitempty"`

	// Maximum transmission unit
	Mtu *int `json:"mtu,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// List of VLANs
	Vlans *[]DeviceVlan `json:"vlans,omitempty"`
}

// DeviceEthernetBase defines model for Device.EthernetBase.
type DeviceEthernetBase struct {

	// Media access control address
	Mac *string `json:"mac,omitempty"`

	// Maximum transmission unit
	Mtu *int `json:"mtu,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// List of VLANs
	Vlans *[]DeviceVlan `json:"vlans,omitempty"`
}

// DeviceIpv4 defines model for Device.Ipv4.
type DeviceIpv4 struct {

	// The IPv4 address
	Address *string `json:"address,omitempty"`

	// Container for emulated BGPv4 peers and routes.
	// Container for basic emulated BGP peer settings.
	Bgpv4 *DeviceBgpv4 `json:"bgpv4,omitempty"`

	// The IPv4 address of the gateway
	Gateway *string `json:"gateway,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// The prefix of the IPv4 address
	Prefix *int `json:"prefix,omitempty"`
}

// DeviceIpv6 defines model for Device.Ipv6.
type DeviceIpv6 struct {

	// The IPv6 address.
	Address *string `json:"address,omitempty"`

	// Container for BGPv6 peer settings and routes.
	// Container for basic emulated BGP peer settings.
	Bgpv6 *DeviceBgpv6 `json:"bgpv6,omitempty"`

	// The IPv6 gateway address
	Gateway *string `json:"gateway,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// The network prefix.
	Prefix *int `json:"prefix,omitempty"`
}

// DeviceVlan defines model for Device.Vlan.
type DeviceVlan struct {

	// VLAN identifier
	Id *int `json:"id,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// Priority code point
	Priority *int `json:"priority,omitempty"`

	// Tag protocol identifier
	Tpid *string `json:"tpid,omitempty"`
}

// Flow defines model for Flow.
type Flow struct {

	// A container for different transmit durations.
	Duration *FlowDuration `json:"duration,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// The header is a list of traffic protocol headers. The order of traffic protocol headers assigned to the list is the order they will appear on the wire.
	Packet *[]FlowHeader `json:"packet,omitempty"`

	// The rate of packet transmission
	Rate *FlowRate `json:"rate,omitempty"`

	// The frame size which overrides the total length of the packet
	Size *FlowSize `json:"size,omitempty"`

	// A container for different types of transmit and receive  endpoint containers.
	TxRx FlowTxRx `json:"tx_rx"`
}

// FlowArp defines model for Flow.Arp.
type FlowArp struct {

	// Length (in octets) of a hardware address
	HardwareLength *PatternFlowArpHardwareLength `json:"hardware_length,omitempty"`

	// Network link protocol type
	HardwareType *PatternFlowArpHardwareType `json:"hardware_type,omitempty"`

	// The operation that the sender is performing
	Operation *PatternFlowArpOperation `json:"operation,omitempty"`

	// Length (in octets) of internetwork addresses
	ProtocolLength *PatternFlowArpProtocolLength `json:"protocol_length,omitempty"`

	// The internetwork protocol for which the ARP request is intended
	ProtocolType *PatternFlowArpProtocolType `json:"protocol_type,omitempty"`

	// Media address of the sender
	SenderHardwareAddr *PatternFlowArpSenderHardwareAddr `json:"sender_hardware_addr,omitempty"`

	// Internetwork address of the sender
	SenderProtocolAddr *PatternFlowArpSenderProtocolAddr `json:"sender_protocol_addr,omitempty"`

	// Media address of the target
	TargetHardwareAddr *PatternFlowArpTargetHardwareAddr `json:"target_hardware_addr,omitempty"`

	// Internetwork address of the target
	TargetProtocolAddr *PatternFlowArpTargetProtocolAddr `json:"target_protocol_addr,omitempty"`
}

// FlowBurst defines model for Flow.Burst.
type FlowBurst struct {

	// The number of packet bursts transmitted per flow. A value of 0 implies continuous burst of packets.
	Bursts *int `json:"bursts,omitempty"`

	// The minimum gap between packets expressed as bytes.
	Gap *int `json:"gap,omitempty"`

	// The optional container for specifying a gap between bursts.
	InterBurstGap *FlowDurationInterBurstGap `json:"inter_burst_gap,omitempty"`

	// The number of packets transmitted per burst.
	Packets *int `json:"packets,omitempty"`
}

// FlowContinuous defines model for Flow.Continuous.
type FlowContinuous struct {

	// The optional container to specify the delay before starting  transmission of packets.
	Delay *FlowDelay `json:"delay,omitempty"`

	// The minimum gap between packets expressed as bytes.
	Gap *int `json:"gap,omitempty"`
}

// FlowCustom defines model for Flow.Custom.
type FlowCustom struct {

	// A custom packet header defined as a string of hex bytes. The string MUST contain sequence of valid hex bytes. Spaces or colons can be part of the bytes but will be discarded. This packet header can be used in multiple places in the packet.
	Bytes string `json:"bytes"`
}

// FlowDelay defines model for Flow.Delay.
type FlowDelay struct {

	// The delay before starting transmission of packets. A value of 0 indicates no delay.
	Bytes  *float32 `json:"bytes,omitempty"`
	Choice string   `json:"choice"`

	// The delay before starting transmission of packets. A value of 0 indicates no delay.
	Microseconds *float32 `json:"microseconds,omitempty"`

	// The delay before starting transmission of packets. A value of 0 indicates no delay.
	Nanoseconds *float32 `json:"nanoseconds,omitempty"`
}

// FlowDevice defines model for Flow.Device.
type FlowDevice struct {

	// Determines the mapping of tx_names to rx_names.
	// The mesh mode creates traffic between each value in tx_names to every value in rx_names except in the case where the individual  tx_names value is equal to rx_names value which will be ignored. Identical values in tx_names or rx_names MUST raise an error.
	// The one_to_one mode creates traffic between each value pair in  of tx_names and rx_names by index. The length of tx_names and rx_name MUST be the same. Identical values in tx_names or rx_names MUST raise an error.
	Mode    string   `json:"mode"`
	RxNames []string `json:"rx_names"`
	TxNames []string `json:"tx_names"`
}

// FlowDuration defines model for Flow.Duration.
type FlowDuration struct {

	// Transmits continuous or fixed burst of packets.  For continuous burst of packets, it will not automatically stop. For fixed burst of packets, it will stop after transmitting fixed number of bursts.
	Burst *FlowBurst `json:"burst,omitempty"`

	// A choice used to determine the type of duration.
	Choice string `json:"choice"`

	// Transmit will be continuous and will not stop automatically.
	Continuous *FlowContinuous `json:"continuous,omitempty"`

	// Transmit a fixed number of packets after which the flow will stop.
	FixedPackets *FlowFixedPackets `json:"fixed_packets,omitempty"`

	// Transmit for a fixed number of seconds after which the flow will stop.
	FixedSeconds *FlowFixedSeconds `json:"fixed_seconds,omitempty"`
}

// FlowDurationInterBurstGap defines model for Flow.Duration.InterBurstGap.
type FlowDurationInterBurstGap struct {

	// The amount of time between bursts expressed in bytes.
	// A value of 0 indicates no gap between bursts.
	Bytes *float64 `json:"bytes,omitempty"`

	// The type of inter burst gap units.
	Choice string `json:"choice"`

	// The amount of time between bursts expressed in microseconds.
	// A value of 0 indicates no gap between bursts.
	Microseconds *float64 `json:"microseconds,omitempty"`

	// The amount of time between bursts expressed in nanoseconds.
	// A value of 0 indicates no gap between bursts.
	Nanoseconds *float64 `json:"nanoseconds,omitempty"`
}

// FlowEthernet defines model for Flow.Ethernet.
type FlowEthernet struct {

	// Destination MAC address
	Dst *PatternFlowEthernetDst `json:"dst,omitempty"`

	// Ethernet type
	EtherType *PatternFlowEthernetEtherType `json:"ether_type,omitempty"`

	// Priority flow control queue
	PfcQueue *PatternFlowEthernetPfcQueue `json:"pfc_queue,omitempty"`

	// Source MAC address
	Src *PatternFlowEthernetSrc `json:"src,omitempty"`
}

// FlowEthernetPause defines model for Flow.EthernetPause.
type FlowEthernetPause struct {

	// Control operation code
	ControlOpCode *PatternFlowEthernetPauseControlOpCode `json:"control_op_code,omitempty"`

	// Destination MAC address
	Dst *PatternFlowEthernetPauseDst `json:"dst,omitempty"`

	// Ethernet type
	EtherType *PatternFlowEthernetPauseEtherType `json:"ether_type,omitempty"`

	// Source MAC address
	Src *PatternFlowEthernetPauseSrc `json:"src,omitempty"`

	// Time
	Time *PatternFlowEthernetPauseTime `json:"time,omitempty"`
}

// FlowFixedPackets defines model for Flow.FixedPackets.
type FlowFixedPackets struct {

	// The optional container to specify the delay before starting  transmission of packets.
	Delay *FlowDelay `json:"delay,omitempty"`

	// The minimum gap between packets expressed as bytes.
	Gap *int `json:"gap,omitempty"`

	// Stop transmit of the flow after this number of packets.
	Packets *int `json:"packets,omitempty"`
}

// FlowFixedSeconds defines model for Flow.FixedSeconds.
type FlowFixedSeconds struct {

	// The optional container to specify the delay before starting  transmission of packets.
	Delay *FlowDelay `json:"delay,omitempty"`

	// The minimum gap between packets expressed as bytes.
	Gap *int `json:"gap,omitempty"`

	// Stop transmit of the flow after this number of seconds.
	Seconds *float32 `json:"seconds,omitempty"`
}

// FlowGre defines model for Flow.Gre.
type FlowGre struct {

	// Optional checksum of GRE header and payload. Only present if the checksum_present bit is set.
	Checksum *PatternFlowGreChecksum `json:"checksum,omitempty"`

	// Checksum present bit
	ChecksumPresent *PatternFlowGreChecksumPresent `json:"checksum_present,omitempty"`

	// Protocol type of encapsulated payload
	Protocol *PatternFlowGreProtocol `json:"protocol,omitempty"`

	// Reserved bits
	Reserved0 *PatternFlowGreReserved0 `json:"reserved0,omitempty"`

	// Optional reserved field. Only present if the checksum_present bit is set.
	Reserved1 *PatternFlowGreReserved1 `json:"reserved1,omitempty"`

	// GRE version number
	Version *PatternFlowGreVersion `json:"version,omitempty"`
}

// FlowGtpExtension defines model for Flow.GtpExtension.
type FlowGtpExtension struct {

	// The extension header contents
	Contents *PatternFlowGtpExtensionContents `json:"contents,omitempty"`

	// This field states the length of this extension header,  including the length, the contents, and the next extension header field, in 4-octet units, so the length of the extension must  always be a multiple of 4.
	ExtensionLength *PatternFlowGtpExtensionExtensionLength `json:"extension_length,omitempty"`

	// It states the type of the next extension, or 0 if no next  extension exists.  This permits chaining several next extension headers.
	NextExtensionHeader *PatternFlowGtpExtensionNextExtensionHeader `json:"next_extension_header,omitempty"`
}

// FlowGtpv1 defines model for Flow.Gtpv1.
type FlowGtpv1 struct {

	// Extension header field present
	EFlag *PatternFlowGtpv1EFlag `json:"e_flag,omitempty"`

	// A list of optional extension headers.
	ExtensionHeaders *[]FlowGtpExtension `json:"extension_headers,omitempty"`

	// The length of the payload (the bytes following the mandatory 8-byte GTP header) in bytes that includes any optional fields
	MessageLength *PatternFlowGtpv1MessageLength `json:"message_length,omitempty"`

	// The type of GTP message Different types of messages are defined in 3GPP TS 29.060 section 7.1
	MessageType *PatternFlowGtpv1MessageType `json:"message_type,omitempty"`

	// N-PDU number. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must be interpreted only if the pn_flag bit is on.
	NPduNumber *PatternFlowGtpv1NPduNumber `json:"n_pdu_number,omitempty"`

	// Next extension header. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must be interpreted only if the e_flag bit is on.
	NextExtensionHeaderType *PatternFlowGtpv1NextExtensionHeaderType `json:"next_extension_header_type,omitempty"`

	// N-PDU field present
	PnFlag *PatternFlowGtpv1PnFlag `json:"pn_flag,omitempty"`

	// Protocol type, GTP is 1, GTP' is 0
	ProtocolType *PatternFlowGtpv1ProtocolType `json:"protocol_type,omitempty"`

	// Reserved field
	Reserved *PatternFlowGtpv1Reserved `json:"reserved,omitempty"`

	// Sequence number field present
	SFlag *PatternFlowGtpv1SFlag `json:"s_flag,omitempty"`

	// Sequence number. Exists if any of the e_flag, s_flag, or pn_flag bits are on.  Must be interpreted only if the s_flag bit is on.
	SquenceNumber *PatternFlowGtpv1SquenceNumber `json:"squence_number,omitempty"`

	// Tunnel endpoint identifier (TEID) used to multiplex connections in the same GTP tunnel
	Teid *PatternFlowGtpv1Teid `json:"teid,omitempty"`

	// GTPv1 version
	Version *PatternFlowGtpv1Version `json:"version,omitempty"`
}

// FlowGtpv2 defines model for Flow.Gtpv2.
type FlowGtpv2 struct {

	// A 16-bit field that indicates the length of the payload in bytes, excluding the mandatory GTP-c header (first 4 bytes). Includes the TEID and sequence_number if they are present.
	MessageLength *PatternFlowGtpv2MessageLength `json:"message_length,omitempty"`

	// An 8-bit field that indicates the type of GTP message. Different types of messages are defined in 3GPP TS 29.060 section 7.1
	MessageType *PatternFlowGtpv2MessageType `json:"message_type,omitempty"`

	// If piggybacking_flag is set to 1 then another GTP-C message with its own header shall be present at the end of the current message
	PiggybackingFlag *PatternFlowGtpv2PiggybackingFlag `json:"piggybacking_flag,omitempty"`

	// The sequence number
	SequenceNumber *PatternFlowGtpv2SequenceNumber `json:"sequence_number,omitempty"`

	// A 3-bit reserved field (must be 0).
	Spare1 *PatternFlowGtpv2Spare1 `json:"spare1,omitempty"`

	// Reserved field
	Spare2 *PatternFlowGtpv2Spare2 `json:"spare2,omitempty"`

	// Tunnel endpoint identifier. A 32-bit (4-octet) field used to multiplex different connections in the same GTP tunnel. Is present only if the teid_flag is set.
	Teid *PatternFlowGtpv2Teid `json:"teid,omitempty"`

	// If teid_flag is set to 1 then the TEID field will be present  between the message length and the sequence number. All messages except Echo and Echo reply require TEID to be present
	TeidFlag *PatternFlowGtpv2TeidFlag `json:"teid_flag,omitempty"`

	// Version number
	Version *PatternFlowGtpv2Version `json:"version,omitempty"`
}

// FlowHeader defines model for Flow.Header.
type FlowHeader struct {

	// ARP packet header
	Arp    *FlowArp `json:"arp,omitempty"`
	Choice string   `json:"choice"`

	// Custom packet header
	Custom *FlowCustom `json:"custom,omitempty"`

	// Ethernet packet header
	Ethernet *FlowEthernet `json:"ethernet,omitempty"`

	// IEEE 802.3x global ethernet pause packet header
	Ethernetpause *FlowEthernetPause `json:"ethernetpause,omitempty"`

	// Standard GRE packet header (RFC2784)
	Gre *FlowGre `json:"gre,omitempty"`

	// GTPv1 packet header
	Gtpv1 *FlowGtpv1 `json:"gtpv1,omitempty"`

	// GTPv2 packet header
	Gtpv2 *FlowGtpv2 `json:"gtpv2,omitempty"`

	// ICMP packet header
	Icmp *FlowIcmp `json:"icmp,omitempty"`

	// ICMPv6 packet header
	Icmpv6 *FlowIcmpv6 `json:"icmpv6,omitempty"`

	// IGMPv1 packet header
	Igmpv1 *FlowIgmpv1 `json:"igmpv1,omitempty"`

	// IPv4 packet header
	Ipv4 *FlowIpv4 `json:"ipv4,omitempty"`

	// IPv6 packet header
	Ipv6 *FlowIpv6 `json:"ipv6,omitempty"`

	// IEEE 802.1Qbb PFC Pause packet header.
	Pfcpause *FlowPfcPause `json:"pfcpause,omitempty"`

	// PPP packet header
	Ppp *FlowPpp `json:"ppp,omitempty"`

	// TCP packet header
	Tcp *FlowTcp `json:"tcp,omitempty"`

	// UDP packet header
	Udp *FlowUdp `json:"udp,omitempty"`

	// VLAN packet header
	Vlan *FlowVlan `json:"vlan,omitempty"`

	// VXLAN packet header
	Vxlan *FlowVxlan `json:"vxlan,omitempty"`
}

// FlowIcmp defines model for Flow.Icmp.
type FlowIcmp struct {
	Choice string `json:"choice"`

	// Packet Header for ICMP echo request
	// Common properties for ICMP packet headers that require checksum
	// Common properties for ICMP packet headers that require identifier and sequence number properties
	Echo *FlowIcmpEcho `json:"echo,omitempty"`
}

// FlowIcmpEcho defines model for Flow.Icmp.Echo.
type FlowIcmpEcho struct {

	// ICMP checksum
	Checksum *PatternFlowIcmpEchoChecksum `json:"checksum,omitempty"`

	// The ICMP subtype.  The default code for ICMP echo request and reply is 0.
	Code *PatternFlowIcmpEchoCode `json:"code,omitempty"`

	// ICMP identifier
	Identifier *PatternFlowIcmpEchoIdentifier `json:"identifier,omitempty"`

	// ICMP sequence number
	SequenceNumber *PatternFlowIcmpEchoSequenceNumber `json:"sequence_number,omitempty"`

	// The type of ICMP echo packet
	Type *PatternFlowIcmpEchoType `json:"type,omitempty"`
}

// FlowIcmpv6 defines model for Flow.Icmpv6.
type FlowIcmpv6 struct {
	Choice string `json:"choice"`

	// Packet Header for ICMPv6 Echo
	// Common properties for ICMPv6 packet headers that require checksum
	Echo *FlowIcmpv6Echo `json:"echo,omitempty"`
}

// FlowIcmpv6Echo defines model for Flow.Icmpv6.Echo.
type FlowIcmpv6Echo struct {

	// ICMPv6 checksum
	Checksum *PatternFlowIcmpv6EchoChecksum `json:"checksum,omitempty"`

	// ICMPv6 echo sub type
	Code *PatternFlowIcmpv6EchoCode `json:"code,omitempty"`

	// ICMPv6 echo identifier
	Identifier *PatternFlowIcmpv6EchoIdentifier `json:"identifier,omitempty"`

	// ICMPv6 echo sequence number
	SequenceNumber *PatternFlowIcmpv6EchoSequenceNumber `json:"sequence_number,omitempty"`

	// ICMPv6 echo type
	Type *PatternFlowIcmpv6EchoType `json:"type,omitempty"`
}

// FlowIgmpv1 defines model for Flow.Igmpv1.
type FlowIgmpv1 struct {

	// Checksum
	Checksum *PatternFlowIgmpv1Checksum `json:"checksum,omitempty"`

	// Group address
	GroupAddress *PatternFlowIgmpv1GroupAddress `json:"group_address,omitempty"`

	// Type of message
	Type *PatternFlowIgmpv1Type `json:"type,omitempty"`

	// Unused
	Unused *PatternFlowIgmpv1Unused `json:"unused,omitempty"`

	// Version number
	Version *PatternFlowIgmpv1Version `json:"version,omitempty"`
}

// FlowIpv4 defines model for Flow.Ipv4.
type FlowIpv4 struct {

	// Dont fragment flag If the dont_fragment flag is set and fragmentation is required to route the packet then the packet is dropped.
	DontFragment *PatternFlowIpv4DontFragment `json:"dont_fragment,omitempty"`

	// Destination address
	Dst *PatternFlowIpv4Dst `json:"dst,omitempty"`

	// Fragment offset
	FragmentOffset *PatternFlowIpv4FragmentOffset `json:"fragment_offset,omitempty"`

	// Header checksum
	HeaderChecksum *PatternFlowIpv4HeaderChecksum `json:"header_checksum,omitempty"`

	// Header length
	HeaderLength *PatternFlowIpv4HeaderLength `json:"header_length,omitempty"`

	// Identification
	Identification *PatternFlowIpv4Identification `json:"identification,omitempty"`

	// More fragments flag
	MoreFragments *PatternFlowIpv4MoreFragments `json:"more_fragments,omitempty"`

	// A container for ipv4 raw, tos, dscp ip priorities.
	Priority *FlowIpv4Priority `json:"priority,omitempty"`

	// Protocol, default is 61 any host internal protocol
	Protocol *PatternFlowIpv4Protocol `json:"protocol,omitempty"`

	// Reserved flag.
	Reserved *PatternFlowIpv4Reserved `json:"reserved,omitempty"`

	// Source address
	Src *PatternFlowIpv4Src `json:"src,omitempty"`

	// Time to live
	TimeToLive *PatternFlowIpv4TimeToLive `json:"time_to_live,omitempty"`

	// Total length
	TotalLength *PatternFlowIpv4TotalLength `json:"total_length,omitempty"`

	// Version
	Version *PatternFlowIpv4Version `json:"version,omitempty"`
}

// FlowIpv4Dscp defines model for Flow.Ipv4.Dscp.
type FlowIpv4Dscp struct {

	// Explicit congestion notification
	Ecn *PatternFlowIpv4DscpEcn `json:"ecn,omitempty"`

	// Per hop behavior
	Phb *PatternFlowIpv4DscpPhb `json:"phb,omitempty"`
}

// FlowIpv4Priority defines model for Flow.Ipv4.Priority.
type FlowIpv4Priority struct {
	Choice string `json:"choice"`

	// Differentiated services code point (DSCP) packet field.
	Dscp *FlowIpv4Dscp `json:"dscp,omitempty"`

	// Raw priority
	Raw *PatternFlowIpv4PriorityRaw `json:"raw,omitempty"`

	// Type of service (TOS) packet field.
	Tos *FlowIpv4Tos `json:"tos,omitempty"`
}

// FlowIpv4Tos defines model for Flow.Ipv4.Tos.
type FlowIpv4Tos struct {

	// Delay
	Delay *PatternFlowIpv4TosDelay `json:"delay,omitempty"`

	// Monetary
	Monetary *PatternFlowIpv4TosMonetary `json:"monetary,omitempty"`

	// Precedence
	Precedence *PatternFlowIpv4TosPrecedence `json:"precedence,omitempty"`

	// Reliability
	Reliability *PatternFlowIpv4TosReliability `json:"reliability,omitempty"`

	// Throughput
	Throughput *PatternFlowIpv4TosThroughput `json:"throughput,omitempty"`

	// Unused
	Unused *PatternFlowIpv4TosUnused `json:"unused,omitempty"`
}

// FlowIpv6 defines model for Flow.Ipv6.
type FlowIpv6 struct {

	// Destination address
	Dst *PatternFlowIpv6Dst `json:"dst,omitempty"`

	// Flow label
	FlowLabel *PatternFlowIpv6FlowLabel `json:"flow_label,omitempty"`

	// Hop limit
	HopLimit *PatternFlowIpv6HopLimit `json:"hop_limit,omitempty"`

	// Next header
	NextHeader *PatternFlowIpv6NextHeader `json:"next_header,omitempty"`

	// Payload length
	PayloadLength *PatternFlowIpv6PayloadLength `json:"payload_length,omitempty"`

	// Source address
	Src *PatternFlowIpv6Src `json:"src,omitempty"`

	// Traffic class
	TrafficClass *PatternFlowIpv6TrafficClass `json:"traffic_class,omitempty"`

	// Version number
	Version *PatternFlowIpv6Version `json:"version,omitempty"`
}

// FlowMetric defines model for Flow.Metric.
type FlowMetric struct {

	// The avarage latency in nanoseconds for valid frames received
	AvgLatencyNs *float32 `json:"avg_latency_ns,omitempty"`

	// The current total number of bytes received
	BytesRx *int `json:"bytes_rx,omitempty"`

	// The current total number of bytes transmitted
	BytesTx *int `json:"bytes_tx,omitempty"`

	// The current total number of valid frames received
	FramesRx *int `json:"frames_rx,omitempty"`

	// The current rate of valid frames received
	FramesRxRate *float32 `json:"frames_rx_rate,omitempty"`

	// The current total number of frames transmitted
	FramesTx *int `json:"frames_tx,omitempty"`

	// The current rate of frames transmitted
	FramesTxRate *float32 `json:"frames_tx_rate,omitempty"`

	// The percentage of lost frames
	Loss *float32 `json:"loss,omitempty"`

	// The maximum latency in nanoseconds for valid frames received
	MaxLatencyNs *float32 `json:"max_latency_ns,omitempty"`

	// Any configured flow packet header field metric_group names will  appear as additional name/value pairs.
	MetricGroups *[]FlowMetricGroup `json:"metric_groups,omitempty"`

	// The minimum latency in nanoseconds for valid frames received
	MinLatencyNs *float32 `json:"min_latency_ns,omitempty"`

	// The name of a configured flow.
	Name *string `json:"name,omitempty"`

	// The name of a configured port
	PortRx *string `json:"port_rx,omitempty"`

	// The name of a configured port
	PortTx *string `json:"port_tx,omitempty"`

	// The transmit state of the flow.
	Transmit *string `json:"transmit,omitempty"`
}

// FlowMetricGroup defines model for Flow.MetricGroup.
type FlowMetricGroup struct {

	// Name provided as part of a flow packet header field metric group
	Name string `json:"name"`

	// The value of the flow packet header field
	Value float32 `json:"value"`
}

// FlowMetricsRequest defines model for Flow.Metrics.Request.
type FlowMetricsRequest struct {

	// The list of column names that the returned result set will contain. If the list is empty then all columns will be returned except for any result_groups. The name of the flow cannot be excluded.
	ColumnNames *[]string `json:"column_names,omitempty"`

	// The names of flow objects to return results for. An empty list will return results for all flows.
	FlowNames *[]string `json:"flow_names,omitempty"`

	// Extend the details of flow metrics by specifying any configured  flow packet header field metric_group names.
	MetricGroupNames *[]string `json:"metric_group_names,omitempty"`
}

// FlowPfcPause defines model for Flow.PfcPause.
type FlowPfcPause struct {

	// Destination
	ClassEnableVector *PatternFlowPfcPauseClassEnableVector `json:"class_enable_vector,omitempty"`

	// Control operation code
	ControlOpCode *PatternFlowPfcPauseControlOpCode `json:"control_op_code,omitempty"`

	// Destination MAC address
	Dst *PatternFlowPfcPauseDst `json:"dst,omitempty"`

	// Ethernet type
	EtherType *PatternFlowPfcPauseEtherType `json:"ether_type,omitempty"`

	// Pause class 0
	PauseClass0 *PatternFlowPfcPausePauseClass0 `json:"pause_class_0,omitempty"`

	// Pause class 1
	PauseClass1 *PatternFlowPfcPausePauseClass1 `json:"pause_class_1,omitempty"`

	// Pause class 2
	PauseClass2 *PatternFlowPfcPausePauseClass2 `json:"pause_class_2,omitempty"`

	// Pause class 3
	PauseClass3 *PatternFlowPfcPausePauseClass3 `json:"pause_class_3,omitempty"`

	// Pause class 4
	PauseClass4 *PatternFlowPfcPausePauseClass4 `json:"pause_class_4,omitempty"`

	// Pause class 5
	PauseClass5 *PatternFlowPfcPausePauseClass5 `json:"pause_class_5,omitempty"`

	// Pause class 6
	PauseClass6 *PatternFlowPfcPausePauseClass6 `json:"pause_class_6,omitempty"`

	// Pause class 7
	PauseClass7 *PatternFlowPfcPausePauseClass7 `json:"pause_class_7,omitempty"`

	// Source MAC address
	Src *PatternFlowPfcPauseSrc `json:"src,omitempty"`
}

// FlowPort defines model for Flow.Port.
type FlowPort struct {

	// The unique name of a port that is the intended receive port.
	RxName *string `json:"rx_name,omitempty"`

	// The unique name of a port that is the transmit port.
	TxName string `json:"tx_name"`
}

// FlowPpp defines model for Flow.Ppp.
type FlowPpp struct {

	// PPP address
	Address *PatternFlowPppAddress `json:"address,omitempty"`

	// PPP control
	Control *PatternFlowPppControl `json:"control,omitempty"`

	// PPP protocol type
	ProtocolType *PatternFlowPppProtocolType `json:"protocol_type,omitempty"`
}

// FlowRate defines model for Flow.Rate.
type FlowRate struct {

	// Bits per second. Default is maximum supported speed.
	Bps    *int   `json:"bps,omitempty"`
	Choice string `json:"choice"`

	// Gigabits per second. Default is maximum supported speed.
	Gbps *float32 `json:"gbps,omitempty"`

	// Kilobits per second. Default is maximum supported speed.
	Kbps *float32 `json:"kbps,omitempty"`

	// Megabits per second.  Default is maximum supported speed.
	Mbps *float32 `json:"mbps,omitempty"`

	// The percentage of a port location's available bandwidth.
	Percentage *float32 `json:"percentage,omitempty"`

	// Packets per second.
	Pps *int `json:"pps,omitempty"`
}

// FlowSize defines model for Flow.Size.
type FlowSize struct {
	Choice string `json:"choice"`
	Fixed  *int   `json:"fixed,omitempty"`

	// Frame size that increments from a starting size to  an ending size incrementing by a step size.
	Increment *FlowSizeIncrement `json:"increment,omitempty"`

	// Random frame size from a min value to a max value.
	Random *FlowSizeRandom `json:"random,omitempty"`
}

// FlowSizeIncrement defines model for Flow.SizeIncrement.
type FlowSizeIncrement struct {

	// Ending frame size in bytes
	End int `json:"end"`

	// Starting frame size in bytes
	Start int `json:"start"`

	// Step frame size in bytes
	Step int `json:"step"`
}

// FlowSizeRandom defines model for Flow.SizeRandom.
type FlowSizeRandom struct {
	Max int `json:"max"`
	Min int `json:"min"`
}

// FlowState defines model for Flow.State.
type FlowState struct {
	Name     *string `json:"name,omitempty"`
	Transmit *string `json:"transmit,omitempty"`
}

// FlowTcp defines model for Flow.Tcp.
type FlowTcp struct {

	// Acknowledgement number
	AckNum *PatternFlowTcpAckNum `json:"ack_num,omitempty"`

	// A value of 1 indicates that the ackknowledgment field is significant.
	CtlAck *PatternFlowTcpCtlAck `json:"ctl_ack,omitempty"`

	// Last packet from the sender.
	CtlFin *PatternFlowTcpCtlFin `json:"ctl_fin,omitempty"`

	// Asks to push the buffered data to the receiving application.
	CtlPsh *PatternFlowTcpCtlPsh `json:"ctl_psh,omitempty"`

	// Reset the connection.
	CtlRst *PatternFlowTcpCtlRst `json:"ctl_rst,omitempty"`

	// Synchronize sequenece numbers.
	CtlSyn *PatternFlowTcpCtlSyn `json:"ctl_syn,omitempty"`

	// A value of 1 indicates that the urgent pointer field is significant.
	CtlUrg *PatternFlowTcpCtlUrg `json:"ctl_urg,omitempty"`

	// The number of 32 bit words in the TCP header. This indicates where the data begins.
	DataOffset *PatternFlowTcpDataOffset `json:"data_offset,omitempty"`

	// Destination port
	DstPort *PatternFlowTcpDstPort `json:"dst_port,omitempty"`

	// Explicit congestion notification, congestion window reduced.
	EcnCwr *PatternFlowTcpEcnCwr `json:"ecn_cwr,omitempty"`

	// Explicit congestion notification, echo. 1 indicates the peer is ecn capable. 0 indicates that a packet with ipv4.ecn = 11 in the ip header was  received during normal transmission.
	EcnEcho *PatternFlowTcpEcnEcho `json:"ecn_echo,omitempty"`

	// Explicit congestion notification, concealment protection.
	EcnNs *PatternFlowTcpEcnNs `json:"ecn_ns,omitempty"`

	// Sequence number
	SeqNum *PatternFlowTcpSeqNum `json:"seq_num,omitempty"`

	// Source port
	SrcPort *PatternFlowTcpSrcPort `json:"src_port,omitempty"`

	// Tcp connection window.
	Window *PatternFlowTcpWindow `json:"window,omitempty"`
}

// FlowTxRx defines model for Flow.TxRx.
type FlowTxRx struct {

	// The type of transmit and receive container used by the flow.
	Choice string `json:"choice"`

	// A container for declaring a map of 1..n transmit devices to 1..n receive devices. This allows for a single flow to have  different tx to rx device flows such as a single one to one map or a  many to many map.
	Device *FlowDevice `json:"device,omitempty"`

	// A container for a transmit port and 0..n intended receive ports. When assigning this container to a flow the flows's  packet headers will not be populated with any address resolution  information such as source and/or destination addresses.  For example Flow.Ethernet dst mac address values will be defaulted to 0.  For full control over the Flow.properties.packet header contents use this  container.
	Port *FlowPort `json:"port,omitempty"`
}

// FlowUdp defines model for Flow.Udp.
type FlowUdp struct {

	// UDP checksum
	Checksum *PatternFlowUdpChecksum `json:"checksum,omitempty"`

	// Destination port
	DstPort *PatternFlowUdpDstPort `json:"dst_port,omitempty"`

	// Length
	Length *PatternFlowUdpLength `json:"length,omitempty"`

	// Source port
	SrcPort *PatternFlowUdpSrcPort `json:"src_port,omitempty"`
}

// FlowVlan defines model for Flow.Vlan.
type FlowVlan struct {

	// Canonical format indicator or drop elegible indicator
	Cfi *PatternFlowVlanCfi `json:"cfi,omitempty"`

	// Vlan identifier
	Id *PatternFlowVlanId `json:"id,omitempty"`

	// Priority code point
	Priority *PatternFlowVlanPriority `json:"priority,omitempty"`

	// Protocol identifier
	Tpid *PatternFlowVlanTpid `json:"tpid,omitempty"`
}

// FlowVxlan defines model for Flow.Vxlan.
type FlowVxlan struct {

	// Flags field with a bit format of RRRRIRRR. The I flag MUST be set to 1 for a valid vxlan network id (VNI).   The other 7 bits (designated "R") are reserved fields and MUST be  set to zero on transmission and ignored on receipt.
	Flags *PatternFlowVxlanFlags `json:"flags,omitempty"`

	// Reserved field
	Reserved0 *PatternFlowVxlanReserved0 `json:"reserved0,omitempty"`

	// Reserved field
	Reserved1 *PatternFlowVxlanReserved1 `json:"reserved1,omitempty"`

	// VXLAN network id
	Vni *PatternFlowVxlanVni `json:"vni,omitempty"`
}

// Lag defines model for Lag.
type Lag struct {

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name  string     `json:"name"`
	Ports *[]LagPort `json:"ports,omitempty"`
}

// LagLacp defines model for Lag.Lacp.
type LagLacp struct {

	// Sets the value of LACP actor activity as either passive or active
	// Passive indicates the port's preference for not transmitting  LACPDUs unless its partner's control is Active
	// Active indicates the port's preference to participate in the  protocol regardless of the partner's control value
	ActorActivity *string `json:"actor_activity,omitempty"`

	// The actor key
	ActorKey *int `json:"actor_key,omitempty"`

	// The actor port number
	ActorPortNumber *int `json:"actor_port_number,omitempty"`

	// The actor port priority
	ActorPortPriority *int `json:"actor_port_priority,omitempty"`

	// The actor system id
	ActorSystemId *string `json:"actor_system_id,omitempty"`

	// The actor system priority
	ActorSystemPriority *int `json:"actor_system_priority,omitempty"`

	// This field defines how frequently LACPDUs are sent to the link partner
	LacpduPeriodicTimeInterval *int `json:"lacpdu_periodic_time_interval,omitempty"`

	// This timer is used to detect whether received protocol information has expired
	LacpduTimeout *int `json:"lacpdu_timeout,omitempty"`
}

// LagPort defines model for Lag.Port.
type LagPort struct {

	// Base ethernet interface
	Ethernet DeviceEthernetBase `json:"ethernet"`

	// The name of a port object that will be part of the LAG.
	PortName string      `json:"port_name"`
	Protocol LagProtocol `json:"protocol"`
}

// LagProtocol defines model for Lag.Protocol.
type LagProtocol struct {

	// The type of LAG protocol.
	Choice string `json:"choice"`

	// The container for link aggregation control protocol settings.
	Lacp *LagLacp `json:"lacp,omitempty"`

	// The container for static link aggregation protocol settings.
	Static *LagStatic `json:"static,omitempty"`
}

// LagStatic defines model for Lag.Static.
type LagStatic struct {

	// The static lag id
	LagId *int `json:"lag_id,omitempty"`
}

// Layer1 defines model for Layer1.
type Layer1 struct {

	// Enable/disable auto negotiation.
	AutoNegotiate *bool `json:"auto_negotiate,omitempty"`

	// Container for auto negotiation settings
	AutoNegotiation *Layer1AutoNegotiation `json:"auto_negotiation,omitempty"`

	// A container for layer1 receive flow control settings. To enable flow control settings on ports this object must be a valid object not a null value.
	FlowControl *Layer1FlowControl `json:"flow_control,omitempty"`

	// Set to true to override the auto_negotiate, link_training and rs_fec settings for gigabit ethernet interfaces.
	IeeeMediaDefaults *bool `json:"ieee_media_defaults,omitempty"`

	// Set the type of media interface if supported.
	Media *string `json:"media,omitempty"`

	// Set the maximum transmission unit size if supported.
	Mtu *int `json:"mtu,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`

	// A list of unique names of port objects that will share the choice settings.
	PortNames []string `json:"port_names"`

	// Enable promiscuous mode if supported.
	Promiscuous *bool `json:"promiscuous,omitempty"`

	// Set the speed if supported.
	Speed *string `json:"speed,omitempty"`
}

// Layer1AutoNegotiation defines model for Layer1.AutoNegotiation.
type Layer1AutoNegotiation struct {

	// If auto_negotiate is true and the interface supports this option then this speed will be advertised.
	Advertise1000Mbps *bool `json:"advertise_1000_mbps,omitempty"`

	// If auto_negotiate is true and the interface supports this option then this speed will be advertised.
	Advertise100FdMbps *bool `json:"advertise_100_fd_mbps,omitempty"`

	// If auto_negotiate is true and the interface supports this option then this speed will be advertised.
	Advertise100HdMbps *bool `json:"advertise_100_hd_mbps,omitempty"`

	// If auto_negotiate is true and the interface supports this option then this speed will be advertised.
	Advertise10FdMbps *bool `json:"advertise_10_fd_mbps,omitempty"`

	// If auto_negotiate is true and the interface supports this option then this speed will be advertised.
	Advertise10HdMbps *bool `json:"advertise_10_hd_mbps,omitempty"`

	// Enable/disable gigabit ethernet link training.
	LinkTraining *bool `json:"link_training,omitempty"`

	// Enable/disable gigabit ethernet reed solomon forward error correction (RS FEC).
	RsFec *bool `json:"rs_fec,omitempty"`
}

// Layer1FlowControl defines model for Layer1.FlowControl.
type Layer1FlowControl struct {

	// The type of priority flow control.
	Choice *string `json:"choice,omitempty"`

	// The 48bit mac address that the layer1 port names will listen on for a directed pause.
	DirectedAddress *string `json:"directed_address,omitempty"`

	// These settings enhance the existing 802.3x pause priority capabilities  to enable flow control based on 802.1p priorities (classes of service).
	Ieee8021qbb *Layer1Ieee8021qbb `json:"ieee_802_1qbb,omitempty"`

	// A container for ieee 802.3x rx pause settings
	Ieee8023x *Layer1Ieee8023x `json:"ieee_802_3x,omitempty"`
}

// Layer1Ieee8021qbb defines model for Layer1.Ieee8021qbb.
type Layer1Ieee8021qbb struct {

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass0 *int `json:"pfc_class_0,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass1 *int `json:"pfc_class_1,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass2 *int `json:"pfc_class_2,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass3 *int `json:"pfc_class_3,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass4 *int `json:"pfc_class_4,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass5 *int `json:"pfc_class_5,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass6 *int `json:"pfc_class_6,omitempty"`

	// The valid values are null, 0 - 7. A null value indicates there is no setting for this pfc class.
	PfcClass7 *int `json:"pfc_class_7,omitempty"`

	// The upper limit on the transmit time of a queue after receiving a  message to pause a specified priority. A value of 0 or null indicates that pfc delay will not be enabled.
	PfcDelay *int `json:"pfc_delay,omitempty"`
}

// Layer1Ieee8023x defines model for Layer1.Ieee8023x.
type Layer1Ieee8023x map[string]interface{}

// LinkState defines model for Link.State.
type LinkState struct {

	// The names of port objects to. An empty or null list will control all port objects.
	PortNames *[]string `json:"port_names,omitempty"`

	// The link state.
	State string `json:"state"`
}

// MetricsRequest defines model for Metrics.Request.
type MetricsRequest struct {

	// The request to retrieve BGPv4 Router statistics and learned routing information
	Bgpv4 *Bgpv4MetricsRequest `json:"bgpv4,omitempty"`

	// The request to retrieve BGPv6 Router statistics and learned routing information
	Bgpv6  *Bgpv6MetricsRequest `json:"bgpv6,omitempty"`
	Choice string               `json:"choice"`

	// The request to the traffic generator for flow results.
	Flow *FlowMetricsRequest `json:"flow,omitempty"`

	// The port result request to the traffic generator
	Port *PortMetricsRequest `json:"port,omitempty"`
}

// MetricsResponse defines model for Metrics.Response.
type MetricsResponse struct {
	Bgpv4Metrics *[]Bgpv4Metric `json:"bgpv4_metrics,omitempty"`
	Bgpv6Metrics *[]Bgpv6Metric `json:"bgpv6_metrics,omitempty"`
	Choice       string         `json:"choice"`
	FlowMetrics  *[]FlowMetric  `json:"flow_metrics,omitempty"`
	PortMetrics  *[]PortMetric  `json:"port_metrics,omitempty"`
}

// PatternFlowArpHardwareLength defines model for Pattern.Flow.Arp.HardwareLength.
type PatternFlowArpHardwareLength struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowArpHardwareLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowArpHardwareLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowArpHardwareLengthCounter defines model for Pattern.Flow.Arp.HardwareLength.Counter.
type PatternFlowArpHardwareLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowArpHardwareType defines model for Pattern.Flow.Arp.HardwareType.
type PatternFlowArpHardwareType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowArpHardwareTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowArpHardwareTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowArpHardwareTypeCounter defines model for Pattern.Flow.Arp.HardwareType.Counter.
type PatternFlowArpHardwareTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowArpOperation defines model for Pattern.Flow.Arp.Operation.
type PatternFlowArpOperation struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowArpOperationCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowArpOperationCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowArpOperationCounter defines model for Pattern.Flow.Arp.Operation.Counter.
type PatternFlowArpOperationCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowArpProtocolLength defines model for Pattern.Flow.Arp.ProtocolLength.
type PatternFlowArpProtocolLength struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowArpProtocolLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowArpProtocolLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowArpProtocolLengthCounter defines model for Pattern.Flow.Arp.ProtocolLength.Counter.
type PatternFlowArpProtocolLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowArpProtocolType defines model for Pattern.Flow.Arp.ProtocolType.
type PatternFlowArpProtocolType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowArpProtocolTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowArpProtocolTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowArpProtocolTypeCounter defines model for Pattern.Flow.Arp.ProtocolType.Counter.
type PatternFlowArpProtocolTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowArpSenderHardwareAddr defines model for Pattern.Flow.Arp.SenderHardwareAddr.
type PatternFlowArpSenderHardwareAddr struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowArpSenderHardwareAddrCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowArpSenderHardwareAddrCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowArpSenderHardwareAddrCounter defines model for Pattern.Flow.Arp.SenderHardwareAddr.Counter.
type PatternFlowArpSenderHardwareAddrCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowArpSenderProtocolAddr defines model for Pattern.Flow.Arp.SenderProtocolAddr.
type PatternFlowArpSenderProtocolAddr struct {
	Choice string `json:"choice"`

	// ipv4 counter pattern
	Decrement *PatternFlowArpSenderProtocolAddrCounter `json:"decrement,omitempty"`

	// ipv4 counter pattern
	Increment *PatternFlowArpSenderProtocolAddrCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowArpSenderProtocolAddrCounter defines model for Pattern.Flow.Arp.SenderProtocolAddr.Counter.
type PatternFlowArpSenderProtocolAddrCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowArpTargetHardwareAddr defines model for Pattern.Flow.Arp.TargetHardwareAddr.
type PatternFlowArpTargetHardwareAddr struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowArpTargetHardwareAddrCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowArpTargetHardwareAddrCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowArpTargetHardwareAddrCounter defines model for Pattern.Flow.Arp.TargetHardwareAddr.Counter.
type PatternFlowArpTargetHardwareAddrCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowArpTargetProtocolAddr defines model for Pattern.Flow.Arp.TargetProtocolAddr.
type PatternFlowArpTargetProtocolAddr struct {
	Choice string `json:"choice"`

	// ipv4 counter pattern
	Decrement *PatternFlowArpTargetProtocolAddrCounter `json:"decrement,omitempty"`

	// ipv4 counter pattern
	Increment *PatternFlowArpTargetProtocolAddrCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowArpTargetProtocolAddrCounter defines model for Pattern.Flow.Arp.TargetProtocolAddr.Counter.
type PatternFlowArpTargetProtocolAddrCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowEthernetDst defines model for Pattern.Flow.Ethernet.Dst.
type PatternFlowEthernetDst struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowEthernetDstCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowEthernetDstCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowEthernetDstCounter defines model for Pattern.Flow.Ethernet.Dst.Counter.
type PatternFlowEthernetDstCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowEthernetEtherType defines model for Pattern.Flow.Ethernet.EtherType.
type PatternFlowEthernetEtherType struct {
	Auto   *string `json:"auto,omitempty"`
	Choice string  `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowEthernetEtherTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowEthernetEtherTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowEthernetEtherTypeCounter defines model for Pattern.Flow.Ethernet.EtherType.Counter.
type PatternFlowEthernetEtherTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowEthernetPfcQueue defines model for Pattern.Flow.Ethernet.PfcQueue.
type PatternFlowEthernetPfcQueue struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowEthernetPfcQueueCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowEthernetPfcQueueCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowEthernetPfcQueueCounter defines model for Pattern.Flow.Ethernet.PfcQueue.Counter.
type PatternFlowEthernetPfcQueueCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowEthernetSrc defines model for Pattern.Flow.Ethernet.Src.
type PatternFlowEthernetSrc struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowEthernetSrcCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowEthernetSrcCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowEthernetSrcCounter defines model for Pattern.Flow.Ethernet.Src.Counter.
type PatternFlowEthernetSrcCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowEthernetPauseControlOpCode defines model for Pattern.Flow.EthernetPause.ControlOpCode.
type PatternFlowEthernetPauseControlOpCode struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowEthernetPauseControlOpCodeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowEthernetPauseControlOpCodeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowEthernetPauseControlOpCodeCounter defines model for Pattern.Flow.EthernetPause.ControlOpCode.Counter.
type PatternFlowEthernetPauseControlOpCodeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowEthernetPauseDst defines model for Pattern.Flow.EthernetPause.Dst.
type PatternFlowEthernetPauseDst struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowEthernetPauseDstCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowEthernetPauseDstCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowEthernetPauseDstCounter defines model for Pattern.Flow.EthernetPause.Dst.Counter.
type PatternFlowEthernetPauseDstCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowEthernetPauseEtherType defines model for Pattern.Flow.EthernetPause.EtherType.
type PatternFlowEthernetPauseEtherType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowEthernetPauseEtherTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowEthernetPauseEtherTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowEthernetPauseEtherTypeCounter defines model for Pattern.Flow.EthernetPause.EtherType.Counter.
type PatternFlowEthernetPauseEtherTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowEthernetPauseSrc defines model for Pattern.Flow.EthernetPause.Src.
type PatternFlowEthernetPauseSrc struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowEthernetPauseSrcCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowEthernetPauseSrcCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowEthernetPauseSrcCounter defines model for Pattern.Flow.EthernetPause.Src.Counter.
type PatternFlowEthernetPauseSrcCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowEthernetPauseTime defines model for Pattern.Flow.EthernetPause.Time.
type PatternFlowEthernetPauseTime struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowEthernetPauseTimeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowEthernetPauseTimeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowEthernetPauseTimeCounter defines model for Pattern.Flow.EthernetPause.Time.Counter.
type PatternFlowEthernetPauseTimeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGreChecksum defines model for Pattern.Flow.Gre.Checksum.
type PatternFlowGreChecksum struct {

	// The type of checksum
	Choice string `json:"choice"`

	// A custom checksum value
	Custom *int `json:"custom,omitempty"`

	// A system generated checksum value
	Generated *string `json:"generated,omitempty"`
}

// PatternFlowGreChecksumPresent defines model for Pattern.Flow.Gre.ChecksumPresent.
type PatternFlowGreChecksumPresent struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGreChecksumPresentCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGreChecksumPresentCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGreChecksumPresentCounter defines model for Pattern.Flow.Gre.ChecksumPresent.Counter.
type PatternFlowGreChecksumPresentCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGreProtocol defines model for Pattern.Flow.Gre.Protocol.
type PatternFlowGreProtocol struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGreProtocolCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGreProtocolCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGreProtocolCounter defines model for Pattern.Flow.Gre.Protocol.Counter.
type PatternFlowGreProtocolCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGreReserved0 defines model for Pattern.Flow.Gre.Reserved0.
type PatternFlowGreReserved0 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGreReserved0Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGreReserved0Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGreReserved0Counter defines model for Pattern.Flow.Gre.Reserved0.Counter.
type PatternFlowGreReserved0Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGreReserved1 defines model for Pattern.Flow.Gre.Reserved1.
type PatternFlowGreReserved1 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGreReserved1Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGreReserved1Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGreReserved1Counter defines model for Pattern.Flow.Gre.Reserved1.Counter.
type PatternFlowGreReserved1Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGreVersion defines model for Pattern.Flow.Gre.Version.
type PatternFlowGreVersion struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGreVersionCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGreVersionCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGreVersionCounter defines model for Pattern.Flow.Gre.Version.Counter.
type PatternFlowGreVersionCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpExtensionContents defines model for Pattern.Flow.GtpExtension.Contents.
type PatternFlowGtpExtensionContents struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpExtensionContentsCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpExtensionContentsCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpExtensionContentsCounter defines model for Pattern.Flow.GtpExtension.Contents.Counter.
type PatternFlowGtpExtensionContentsCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpExtensionExtensionLength defines model for Pattern.Flow.GtpExtension.ExtensionLength.
type PatternFlowGtpExtensionExtensionLength struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpExtensionExtensionLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpExtensionExtensionLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpExtensionExtensionLengthCounter defines model for Pattern.Flow.GtpExtension.ExtensionLength.Counter.
type PatternFlowGtpExtensionExtensionLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpExtensionNextExtensionHeader defines model for Pattern.Flow.GtpExtension.NextExtensionHeader.
type PatternFlowGtpExtensionNextExtensionHeader struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpExtensionNextExtensionHeaderCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpExtensionNextExtensionHeaderCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpExtensionNextExtensionHeaderCounter defines model for Pattern.Flow.GtpExtension.NextExtensionHeader.Counter.
type PatternFlowGtpExtensionNextExtensionHeaderCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1EFlag defines model for Pattern.Flow.Gtpv1.EFlag.
type PatternFlowGtpv1EFlag struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1EFlagCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1EFlagCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1EFlagCounter defines model for Pattern.Flow.Gtpv1.EFlag.Counter.
type PatternFlowGtpv1EFlagCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1MessageLength defines model for Pattern.Flow.Gtpv1.MessageLength.
type PatternFlowGtpv1MessageLength struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1MessageLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1MessageLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1MessageLengthCounter defines model for Pattern.Flow.Gtpv1.MessageLength.Counter.
type PatternFlowGtpv1MessageLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1MessageType defines model for Pattern.Flow.Gtpv1.MessageType.
type PatternFlowGtpv1MessageType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1MessageTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1MessageTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1MessageTypeCounter defines model for Pattern.Flow.Gtpv1.MessageType.Counter.
type PatternFlowGtpv1MessageTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1NPduNumber defines model for Pattern.Flow.Gtpv1.NPduNumber.
type PatternFlowGtpv1NPduNumber struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1NPduNumberCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1NPduNumberCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1NPduNumberCounter defines model for Pattern.Flow.Gtpv1.NPduNumber.Counter.
type PatternFlowGtpv1NPduNumberCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1NextExtensionHeaderType defines model for Pattern.Flow.Gtpv1.NextExtensionHeaderType.
type PatternFlowGtpv1NextExtensionHeaderType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1NextExtensionHeaderTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1NextExtensionHeaderTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1NextExtensionHeaderTypeCounter defines model for Pattern.Flow.Gtpv1.NextExtensionHeaderType.Counter.
type PatternFlowGtpv1NextExtensionHeaderTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1PnFlag defines model for Pattern.Flow.Gtpv1.PnFlag.
type PatternFlowGtpv1PnFlag struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1PnFlagCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1PnFlagCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1PnFlagCounter defines model for Pattern.Flow.Gtpv1.PnFlag.Counter.
type PatternFlowGtpv1PnFlagCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1ProtocolType defines model for Pattern.Flow.Gtpv1.ProtocolType.
type PatternFlowGtpv1ProtocolType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1ProtocolTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1ProtocolTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1ProtocolTypeCounter defines model for Pattern.Flow.Gtpv1.ProtocolType.Counter.
type PatternFlowGtpv1ProtocolTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1Reserved defines model for Pattern.Flow.Gtpv1.Reserved.
type PatternFlowGtpv1Reserved struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1ReservedCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1ReservedCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1ReservedCounter defines model for Pattern.Flow.Gtpv1.Reserved.Counter.
type PatternFlowGtpv1ReservedCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1SFlag defines model for Pattern.Flow.Gtpv1.SFlag.
type PatternFlowGtpv1SFlag struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1SFlagCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1SFlagCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1SFlagCounter defines model for Pattern.Flow.Gtpv1.SFlag.Counter.
type PatternFlowGtpv1SFlagCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1SquenceNumber defines model for Pattern.Flow.Gtpv1.SquenceNumber.
type PatternFlowGtpv1SquenceNumber struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1SquenceNumberCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1SquenceNumberCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1SquenceNumberCounter defines model for Pattern.Flow.Gtpv1.SquenceNumber.Counter.
type PatternFlowGtpv1SquenceNumberCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1Teid defines model for Pattern.Flow.Gtpv1.Teid.
type PatternFlowGtpv1Teid struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1TeidCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1TeidCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1TeidCounter defines model for Pattern.Flow.Gtpv1.Teid.Counter.
type PatternFlowGtpv1TeidCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv1Version defines model for Pattern.Flow.Gtpv1.Version.
type PatternFlowGtpv1Version struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv1VersionCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv1VersionCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv1VersionCounter defines model for Pattern.Flow.Gtpv1.Version.Counter.
type PatternFlowGtpv1VersionCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2MessageLength defines model for Pattern.Flow.Gtpv2.MessageLength.
type PatternFlowGtpv2MessageLength struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2MessageLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2MessageLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2MessageLengthCounter defines model for Pattern.Flow.Gtpv2.MessageLength.Counter.
type PatternFlowGtpv2MessageLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2MessageType defines model for Pattern.Flow.Gtpv2.MessageType.
type PatternFlowGtpv2MessageType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2MessageTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2MessageTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2MessageTypeCounter defines model for Pattern.Flow.Gtpv2.MessageType.Counter.
type PatternFlowGtpv2MessageTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2PiggybackingFlag defines model for Pattern.Flow.Gtpv2.PiggybackingFlag.
type PatternFlowGtpv2PiggybackingFlag struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2PiggybackingFlagCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2PiggybackingFlagCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2PiggybackingFlagCounter defines model for Pattern.Flow.Gtpv2.PiggybackingFlag.Counter.
type PatternFlowGtpv2PiggybackingFlagCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2SequenceNumber defines model for Pattern.Flow.Gtpv2.SequenceNumber.
type PatternFlowGtpv2SequenceNumber struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2SequenceNumberCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2SequenceNumberCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2SequenceNumberCounter defines model for Pattern.Flow.Gtpv2.SequenceNumber.Counter.
type PatternFlowGtpv2SequenceNumberCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2Spare1 defines model for Pattern.Flow.Gtpv2.Spare1.
type PatternFlowGtpv2Spare1 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2Spare1Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2Spare1Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2Spare1Counter defines model for Pattern.Flow.Gtpv2.Spare1.Counter.
type PatternFlowGtpv2Spare1Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2Spare2 defines model for Pattern.Flow.Gtpv2.Spare2.
type PatternFlowGtpv2Spare2 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2Spare2Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2Spare2Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2Spare2Counter defines model for Pattern.Flow.Gtpv2.Spare2.Counter.
type PatternFlowGtpv2Spare2Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2Teid defines model for Pattern.Flow.Gtpv2.Teid.
type PatternFlowGtpv2Teid struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2TeidCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2TeidCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2TeidCounter defines model for Pattern.Flow.Gtpv2.Teid.Counter.
type PatternFlowGtpv2TeidCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2TeidFlag defines model for Pattern.Flow.Gtpv2.TeidFlag.
type PatternFlowGtpv2TeidFlag struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2TeidFlagCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2TeidFlagCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2TeidFlagCounter defines model for Pattern.Flow.Gtpv2.TeidFlag.Counter.
type PatternFlowGtpv2TeidFlagCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowGtpv2Version defines model for Pattern.Flow.Gtpv2.Version.
type PatternFlowGtpv2Version struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowGtpv2VersionCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowGtpv2VersionCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowGtpv2VersionCounter defines model for Pattern.Flow.Gtpv2.Version.Counter.
type PatternFlowGtpv2VersionCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpEchoChecksum defines model for Pattern.Flow.Icmp.Echo.Checksum.
type PatternFlowIcmpEchoChecksum struct {

	// The type of checksum
	Choice string `json:"choice"`

	// A custom checksum value
	Custom *int `json:"custom,omitempty"`

	// A system generated checksum value
	Generated *string `json:"generated,omitempty"`
}

// PatternFlowIcmpEchoCode defines model for Pattern.Flow.Icmp.Echo.Code.
type PatternFlowIcmpEchoCode struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpEchoCodeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpEchoCodeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpEchoCodeCounter defines model for Pattern.Flow.Icmp.Echo.Code.Counter.
type PatternFlowIcmpEchoCodeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpEchoIdentifier defines model for Pattern.Flow.Icmp.Echo.Identifier.
type PatternFlowIcmpEchoIdentifier struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpEchoIdentifierCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpEchoIdentifierCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpEchoIdentifierCounter defines model for Pattern.Flow.Icmp.Echo.Identifier.Counter.
type PatternFlowIcmpEchoIdentifierCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpEchoSequenceNumber defines model for Pattern.Flow.Icmp.Echo.SequenceNumber.
type PatternFlowIcmpEchoSequenceNumber struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpEchoSequenceNumberCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpEchoSequenceNumberCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpEchoSequenceNumberCounter defines model for Pattern.Flow.Icmp.Echo.SequenceNumber.Counter.
type PatternFlowIcmpEchoSequenceNumberCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpEchoType defines model for Pattern.Flow.Icmp.Echo.Type.
type PatternFlowIcmpEchoType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpEchoTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpEchoTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpEchoTypeCounter defines model for Pattern.Flow.Icmp.Echo.Type.Counter.
type PatternFlowIcmpEchoTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpv6EchoChecksum defines model for Pattern.Flow.Icmpv6.Echo.Checksum.
type PatternFlowIcmpv6EchoChecksum struct {

	// The type of checksum
	Choice string `json:"choice"`

	// A custom checksum value
	Custom *int `json:"custom,omitempty"`

	// A system generated checksum value
	Generated *string `json:"generated,omitempty"`
}

// PatternFlowIcmpv6EchoCode defines model for Pattern.Flow.Icmpv6.Echo.Code.
type PatternFlowIcmpv6EchoCode struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpv6EchoCodeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpv6EchoCodeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpv6EchoCodeCounter defines model for Pattern.Flow.Icmpv6.Echo.Code.Counter.
type PatternFlowIcmpv6EchoCodeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpv6EchoIdentifier defines model for Pattern.Flow.Icmpv6.Echo.Identifier.
type PatternFlowIcmpv6EchoIdentifier struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpv6EchoIdentifierCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpv6EchoIdentifierCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpv6EchoIdentifierCounter defines model for Pattern.Flow.Icmpv6.Echo.Identifier.Counter.
type PatternFlowIcmpv6EchoIdentifierCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpv6EchoSequenceNumber defines model for Pattern.Flow.Icmpv6.Echo.SequenceNumber.
type PatternFlowIcmpv6EchoSequenceNumber struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpv6EchoSequenceNumberCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpv6EchoSequenceNumberCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpv6EchoSequenceNumberCounter defines model for Pattern.Flow.Icmpv6.Echo.SequenceNumber.Counter.
type PatternFlowIcmpv6EchoSequenceNumberCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIcmpv6EchoType defines model for Pattern.Flow.Icmpv6.Echo.Type.
type PatternFlowIcmpv6EchoType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIcmpv6EchoTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIcmpv6EchoTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIcmpv6EchoTypeCounter defines model for Pattern.Flow.Icmpv6.Echo.Type.Counter.
type PatternFlowIcmpv6EchoTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIgmpv1Checksum defines model for Pattern.Flow.Igmpv1.Checksum.
type PatternFlowIgmpv1Checksum struct {

	// The type of checksum
	Choice string `json:"choice"`

	// A custom checksum value
	Custom *int `json:"custom,omitempty"`

	// A system generated checksum value
	Generated *string `json:"generated,omitempty"`
}

// PatternFlowIgmpv1GroupAddress defines model for Pattern.Flow.Igmpv1.GroupAddress.
type PatternFlowIgmpv1GroupAddress struct {
	Choice string `json:"choice"`

	// ipv4 counter pattern
	Decrement *PatternFlowIgmpv1GroupAddressCounter `json:"decrement,omitempty"`

	// ipv4 counter pattern
	Increment *PatternFlowIgmpv1GroupAddressCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowIgmpv1GroupAddressCounter defines model for Pattern.Flow.Igmpv1.GroupAddress.Counter.
type PatternFlowIgmpv1GroupAddressCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowIgmpv1Type defines model for Pattern.Flow.Igmpv1.Type.
type PatternFlowIgmpv1Type struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIgmpv1TypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIgmpv1TypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIgmpv1TypeCounter defines model for Pattern.Flow.Igmpv1.Type.Counter.
type PatternFlowIgmpv1TypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIgmpv1Unused defines model for Pattern.Flow.Igmpv1.Unused.
type PatternFlowIgmpv1Unused struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIgmpv1UnusedCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIgmpv1UnusedCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIgmpv1UnusedCounter defines model for Pattern.Flow.Igmpv1.Unused.Counter.
type PatternFlowIgmpv1UnusedCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIgmpv1Version defines model for Pattern.Flow.Igmpv1.Version.
type PatternFlowIgmpv1Version struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIgmpv1VersionCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIgmpv1VersionCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIgmpv1VersionCounter defines model for Pattern.Flow.Igmpv1.Version.Counter.
type PatternFlowIgmpv1VersionCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4DontFragment defines model for Pattern.Flow.Ipv4.DontFragment.
type PatternFlowIpv4DontFragment struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4DontFragmentCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4DontFragmentCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4DontFragmentCounter defines model for Pattern.Flow.Ipv4.DontFragment.Counter.
type PatternFlowIpv4DontFragmentCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4DscpEcn defines model for Pattern.Flow.Ipv4.Dscp.Ecn.
type PatternFlowIpv4DscpEcn struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4DscpEcnCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4DscpEcnCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4DscpEcnCounter defines model for Pattern.Flow.Ipv4.Dscp.Ecn.Counter.
type PatternFlowIpv4DscpEcnCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4DscpPhb defines model for Pattern.Flow.Ipv4.Dscp.Phb.
type PatternFlowIpv4DscpPhb struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4DscpPhbCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4DscpPhbCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4DscpPhbCounter defines model for Pattern.Flow.Ipv4.Dscp.Phb.Counter.
type PatternFlowIpv4DscpPhbCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4Dst defines model for Pattern.Flow.Ipv4.Dst.
type PatternFlowIpv4Dst struct {
	Choice string `json:"choice"`

	// ipv4 counter pattern
	Decrement *PatternFlowIpv4DstCounter `json:"decrement,omitempty"`

	// ipv4 counter pattern
	Increment *PatternFlowIpv4DstCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowIpv4DstCounter defines model for Pattern.Flow.Ipv4.Dst.Counter.
type PatternFlowIpv4DstCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowIpv4FragmentOffset defines model for Pattern.Flow.Ipv4.FragmentOffset.
type PatternFlowIpv4FragmentOffset struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4FragmentOffsetCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4FragmentOffsetCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4FragmentOffsetCounter defines model for Pattern.Flow.Ipv4.FragmentOffset.Counter.
type PatternFlowIpv4FragmentOffsetCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4HeaderChecksum defines model for Pattern.Flow.Ipv4.HeaderChecksum.
type PatternFlowIpv4HeaderChecksum struct {

	// The type of checksum
	Choice string `json:"choice"`

	// A custom checksum value
	Custom *int `json:"custom,omitempty"`

	// A system generated checksum value
	Generated *string `json:"generated,omitempty"`
}

// PatternFlowIpv4HeaderLength defines model for Pattern.Flow.Ipv4.HeaderLength.
type PatternFlowIpv4HeaderLength struct {
	Auto   *string `json:"auto,omitempty"`
	Choice string  `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4HeaderLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4HeaderLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4HeaderLengthCounter defines model for Pattern.Flow.Ipv4.HeaderLength.Counter.
type PatternFlowIpv4HeaderLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4Identification defines model for Pattern.Flow.Ipv4.Identification.
type PatternFlowIpv4Identification struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4IdentificationCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4IdentificationCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4IdentificationCounter defines model for Pattern.Flow.Ipv4.Identification.Counter.
type PatternFlowIpv4IdentificationCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4MoreFragments defines model for Pattern.Flow.Ipv4.MoreFragments.
type PatternFlowIpv4MoreFragments struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4MoreFragmentsCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4MoreFragmentsCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4MoreFragmentsCounter defines model for Pattern.Flow.Ipv4.MoreFragments.Counter.
type PatternFlowIpv4MoreFragmentsCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4PriorityRaw defines model for Pattern.Flow.Ipv4.Priority.Raw.
type PatternFlowIpv4PriorityRaw struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4PriorityRawCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4PriorityRawCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4PriorityRawCounter defines model for Pattern.Flow.Ipv4.Priority.Raw.Counter.
type PatternFlowIpv4PriorityRawCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4Protocol defines model for Pattern.Flow.Ipv4.Protocol.
type PatternFlowIpv4Protocol struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4ProtocolCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4ProtocolCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4ProtocolCounter defines model for Pattern.Flow.Ipv4.Protocol.Counter.
type PatternFlowIpv4ProtocolCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4Reserved defines model for Pattern.Flow.Ipv4.Reserved.
type PatternFlowIpv4Reserved struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4ReservedCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4ReservedCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4ReservedCounter defines model for Pattern.Flow.Ipv4.Reserved.Counter.
type PatternFlowIpv4ReservedCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4Src defines model for Pattern.Flow.Ipv4.Src.
type PatternFlowIpv4Src struct {
	Choice string `json:"choice"`

	// ipv4 counter pattern
	Decrement *PatternFlowIpv4SrcCounter `json:"decrement,omitempty"`

	// ipv4 counter pattern
	Increment *PatternFlowIpv4SrcCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowIpv4SrcCounter defines model for Pattern.Flow.Ipv4.Src.Counter.
type PatternFlowIpv4SrcCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowIpv4TimeToLive defines model for Pattern.Flow.Ipv4.TimeToLive.
type PatternFlowIpv4TimeToLive struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TimeToLiveCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TimeToLiveCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TimeToLiveCounter defines model for Pattern.Flow.Ipv4.TimeToLive.Counter.
type PatternFlowIpv4TimeToLiveCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TosDelay defines model for Pattern.Flow.Ipv4.Tos.Delay.
type PatternFlowIpv4TosDelay struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TosDelayCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TosDelayCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TosDelayCounter defines model for Pattern.Flow.Ipv4.Tos.Delay.Counter.
type PatternFlowIpv4TosDelayCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TosMonetary defines model for Pattern.Flow.Ipv4.Tos.Monetary.
type PatternFlowIpv4TosMonetary struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TosMonetaryCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TosMonetaryCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TosMonetaryCounter defines model for Pattern.Flow.Ipv4.Tos.Monetary.Counter.
type PatternFlowIpv4TosMonetaryCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TosPrecedence defines model for Pattern.Flow.Ipv4.Tos.Precedence.
type PatternFlowIpv4TosPrecedence struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TosPrecedenceCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TosPrecedenceCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TosPrecedenceCounter defines model for Pattern.Flow.Ipv4.Tos.Precedence.Counter.
type PatternFlowIpv4TosPrecedenceCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TosReliability defines model for Pattern.Flow.Ipv4.Tos.Reliability.
type PatternFlowIpv4TosReliability struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TosReliabilityCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TosReliabilityCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TosReliabilityCounter defines model for Pattern.Flow.Ipv4.Tos.Reliability.Counter.
type PatternFlowIpv4TosReliabilityCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TosThroughput defines model for Pattern.Flow.Ipv4.Tos.Throughput.
type PatternFlowIpv4TosThroughput struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TosThroughputCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TosThroughputCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TosThroughputCounter defines model for Pattern.Flow.Ipv4.Tos.Throughput.Counter.
type PatternFlowIpv4TosThroughputCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TosUnused defines model for Pattern.Flow.Ipv4.Tos.Unused.
type PatternFlowIpv4TosUnused struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TosUnusedCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TosUnusedCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TosUnusedCounter defines model for Pattern.Flow.Ipv4.Tos.Unused.Counter.
type PatternFlowIpv4TosUnusedCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4TotalLength defines model for Pattern.Flow.Ipv4.TotalLength.
type PatternFlowIpv4TotalLength struct {
	Auto   *string `json:"auto,omitempty"`
	Choice string  `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4TotalLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4TotalLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4TotalLengthCounter defines model for Pattern.Flow.Ipv4.TotalLength.Counter.
type PatternFlowIpv4TotalLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv4Version defines model for Pattern.Flow.Ipv4.Version.
type PatternFlowIpv4Version struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv4VersionCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv4VersionCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv4VersionCounter defines model for Pattern.Flow.Ipv4.Version.Counter.
type PatternFlowIpv4VersionCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv6Dst defines model for Pattern.Flow.Ipv6.Dst.
type PatternFlowIpv6Dst struct {
	Choice string `json:"choice"`

	// ipv6 counter pattern
	Decrement *PatternFlowIpv6DstCounter `json:"decrement,omitempty"`

	// ipv6 counter pattern
	Increment *PatternFlowIpv6DstCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowIpv6DstCounter defines model for Pattern.Flow.Ipv6.Dst.Counter.
type PatternFlowIpv6DstCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowIpv6FlowLabel defines model for Pattern.Flow.Ipv6.FlowLabel.
type PatternFlowIpv6FlowLabel struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv6FlowLabelCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv6FlowLabelCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv6FlowLabelCounter defines model for Pattern.Flow.Ipv6.FlowLabel.Counter.
type PatternFlowIpv6FlowLabelCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv6HopLimit defines model for Pattern.Flow.Ipv6.HopLimit.
type PatternFlowIpv6HopLimit struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv6HopLimitCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv6HopLimitCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv6HopLimitCounter defines model for Pattern.Flow.Ipv6.HopLimit.Counter.
type PatternFlowIpv6HopLimitCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv6NextHeader defines model for Pattern.Flow.Ipv6.NextHeader.
type PatternFlowIpv6NextHeader struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv6NextHeaderCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv6NextHeaderCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv6NextHeaderCounter defines model for Pattern.Flow.Ipv6.NextHeader.Counter.
type PatternFlowIpv6NextHeaderCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv6PayloadLength defines model for Pattern.Flow.Ipv6.PayloadLength.
type PatternFlowIpv6PayloadLength struct {
	Auto   *string `json:"auto,omitempty"`
	Choice string  `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv6PayloadLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv6PayloadLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv6PayloadLengthCounter defines model for Pattern.Flow.Ipv6.PayloadLength.Counter.
type PatternFlowIpv6PayloadLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv6Src defines model for Pattern.Flow.Ipv6.Src.
type PatternFlowIpv6Src struct {
	Choice string `json:"choice"`

	// ipv6 counter pattern
	Decrement *PatternFlowIpv6SrcCounter `json:"decrement,omitempty"`

	// ipv6 counter pattern
	Increment *PatternFlowIpv6SrcCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowIpv6SrcCounter defines model for Pattern.Flow.Ipv6.Src.Counter.
type PatternFlowIpv6SrcCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowIpv6TrafficClass defines model for Pattern.Flow.Ipv6.TrafficClass.
type PatternFlowIpv6TrafficClass struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv6TrafficClassCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv6TrafficClassCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv6TrafficClassCounter defines model for Pattern.Flow.Ipv6.TrafficClass.Counter.
type PatternFlowIpv6TrafficClassCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowIpv6Version defines model for Pattern.Flow.Ipv6.Version.
type PatternFlowIpv6Version struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowIpv6VersionCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowIpv6VersionCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowIpv6VersionCounter defines model for Pattern.Flow.Ipv6.Version.Counter.
type PatternFlowIpv6VersionCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPauseClassEnableVector defines model for Pattern.Flow.PfcPause.ClassEnableVector.
type PatternFlowPfcPauseClassEnableVector struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPauseClassEnableVectorCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPauseClassEnableVectorCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPauseClassEnableVectorCounter defines model for Pattern.Flow.PfcPause.ClassEnableVector.Counter.
type PatternFlowPfcPauseClassEnableVectorCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPauseControlOpCode defines model for Pattern.Flow.PfcPause.ControlOpCode.
type PatternFlowPfcPauseControlOpCode struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPauseControlOpCodeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPauseControlOpCodeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPauseControlOpCodeCounter defines model for Pattern.Flow.PfcPause.ControlOpCode.Counter.
type PatternFlowPfcPauseControlOpCodeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPauseDst defines model for Pattern.Flow.PfcPause.Dst.
type PatternFlowPfcPauseDst struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowPfcPauseDstCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowPfcPauseDstCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowPfcPauseDstCounter defines model for Pattern.Flow.PfcPause.Dst.Counter.
type PatternFlowPfcPauseDstCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowPfcPauseEtherType defines model for Pattern.Flow.PfcPause.EtherType.
type PatternFlowPfcPauseEtherType struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPauseEtherTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPauseEtherTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPauseEtherTypeCounter defines model for Pattern.Flow.PfcPause.EtherType.Counter.
type PatternFlowPfcPauseEtherTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass0 defines model for Pattern.Flow.PfcPause.PauseClass0.
type PatternFlowPfcPausePauseClass0 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass0Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass0Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass0Counter defines model for Pattern.Flow.PfcPause.PauseClass0.Counter.
type PatternFlowPfcPausePauseClass0Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass1 defines model for Pattern.Flow.PfcPause.PauseClass1.
type PatternFlowPfcPausePauseClass1 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass1Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass1Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass1Counter defines model for Pattern.Flow.PfcPause.PauseClass1.Counter.
type PatternFlowPfcPausePauseClass1Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass2 defines model for Pattern.Flow.PfcPause.PauseClass2.
type PatternFlowPfcPausePauseClass2 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass2Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass2Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass2Counter defines model for Pattern.Flow.PfcPause.PauseClass2.Counter.
type PatternFlowPfcPausePauseClass2Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass3 defines model for Pattern.Flow.PfcPause.PauseClass3.
type PatternFlowPfcPausePauseClass3 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass3Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass3Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass3Counter defines model for Pattern.Flow.PfcPause.PauseClass3.Counter.
type PatternFlowPfcPausePauseClass3Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass4 defines model for Pattern.Flow.PfcPause.PauseClass4.
type PatternFlowPfcPausePauseClass4 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass4Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass4Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass4Counter defines model for Pattern.Flow.PfcPause.PauseClass4.Counter.
type PatternFlowPfcPausePauseClass4Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass5 defines model for Pattern.Flow.PfcPause.PauseClass5.
type PatternFlowPfcPausePauseClass5 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass5Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass5Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass5Counter defines model for Pattern.Flow.PfcPause.PauseClass5.Counter.
type PatternFlowPfcPausePauseClass5Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass6 defines model for Pattern.Flow.PfcPause.PauseClass6.
type PatternFlowPfcPausePauseClass6 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass6Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass6Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass6Counter defines model for Pattern.Flow.PfcPause.PauseClass6.Counter.
type PatternFlowPfcPausePauseClass6Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPausePauseClass7 defines model for Pattern.Flow.PfcPause.PauseClass7.
type PatternFlowPfcPausePauseClass7 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPfcPausePauseClass7Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPfcPausePauseClass7Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPfcPausePauseClass7Counter defines model for Pattern.Flow.PfcPause.PauseClass7.Counter.
type PatternFlowPfcPausePauseClass7Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPfcPauseSrc defines model for Pattern.Flow.PfcPause.Src.
type PatternFlowPfcPauseSrc struct {
	Choice string `json:"choice"`

	// mac counter pattern
	Decrement *PatternFlowPfcPauseSrcCounter `json:"decrement,omitempty"`

	// mac counter pattern
	Increment *PatternFlowPfcPauseSrcCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string   `json:"metric_group,omitempty"`
	Value       *string   `json:"value,omitempty"`
	Values      *[]string `json:"values,omitempty"`
}

// PatternFlowPfcPauseSrcCounter defines model for Pattern.Flow.PfcPause.Src.Counter.
type PatternFlowPfcPauseSrcCounter struct {
	Count *int   `json:"count,omitempty"`
	Start string `json:"start"`
	Step  string `json:"step"`
}

// PatternFlowPppAddress defines model for Pattern.Flow.Ppp.Address.
type PatternFlowPppAddress struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPppAddressCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPppAddressCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPppAddressCounter defines model for Pattern.Flow.Ppp.Address.Counter.
type PatternFlowPppAddressCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPppControl defines model for Pattern.Flow.Ppp.Control.
type PatternFlowPppControl struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPppControlCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPppControlCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPppControlCounter defines model for Pattern.Flow.Ppp.Control.Counter.
type PatternFlowPppControlCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowPppProtocolType defines model for Pattern.Flow.Ppp.ProtocolType.
type PatternFlowPppProtocolType struct {
	Auto   *string `json:"auto,omitempty"`
	Choice string  `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowPppProtocolTypeCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowPppProtocolTypeCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowPppProtocolTypeCounter defines model for Pattern.Flow.Ppp.ProtocolType.Counter.
type PatternFlowPppProtocolTypeCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpAckNum defines model for Pattern.Flow.Tcp.AckNum.
type PatternFlowTcpAckNum struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpAckNumCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpAckNumCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpAckNumCounter defines model for Pattern.Flow.Tcp.AckNum.Counter.
type PatternFlowTcpAckNumCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpCtlAck defines model for Pattern.Flow.Tcp.CtlAck.
type PatternFlowTcpCtlAck struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpCtlAckCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpCtlAckCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpCtlAckCounter defines model for Pattern.Flow.Tcp.CtlAck.Counter.
type PatternFlowTcpCtlAckCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpCtlFin defines model for Pattern.Flow.Tcp.CtlFin.
type PatternFlowTcpCtlFin struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpCtlFinCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpCtlFinCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpCtlFinCounter defines model for Pattern.Flow.Tcp.CtlFin.Counter.
type PatternFlowTcpCtlFinCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpCtlPsh defines model for Pattern.Flow.Tcp.CtlPsh.
type PatternFlowTcpCtlPsh struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpCtlPshCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpCtlPshCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpCtlPshCounter defines model for Pattern.Flow.Tcp.CtlPsh.Counter.
type PatternFlowTcpCtlPshCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpCtlRst defines model for Pattern.Flow.Tcp.CtlRst.
type PatternFlowTcpCtlRst struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpCtlRstCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpCtlRstCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpCtlRstCounter defines model for Pattern.Flow.Tcp.CtlRst.Counter.
type PatternFlowTcpCtlRstCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpCtlSyn defines model for Pattern.Flow.Tcp.CtlSyn.
type PatternFlowTcpCtlSyn struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpCtlSynCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpCtlSynCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpCtlSynCounter defines model for Pattern.Flow.Tcp.CtlSyn.Counter.
type PatternFlowTcpCtlSynCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpCtlUrg defines model for Pattern.Flow.Tcp.CtlUrg.
type PatternFlowTcpCtlUrg struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpCtlUrgCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpCtlUrgCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpCtlUrgCounter defines model for Pattern.Flow.Tcp.CtlUrg.Counter.
type PatternFlowTcpCtlUrgCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpDataOffset defines model for Pattern.Flow.Tcp.DataOffset.
type PatternFlowTcpDataOffset struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpDataOffsetCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpDataOffsetCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpDataOffsetCounter defines model for Pattern.Flow.Tcp.DataOffset.Counter.
type PatternFlowTcpDataOffsetCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpDstPort defines model for Pattern.Flow.Tcp.DstPort.
type PatternFlowTcpDstPort struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpDstPortCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpDstPortCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpDstPortCounter defines model for Pattern.Flow.Tcp.DstPort.Counter.
type PatternFlowTcpDstPortCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpEcnCwr defines model for Pattern.Flow.Tcp.EcnCwr.
type PatternFlowTcpEcnCwr struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpEcnCwrCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpEcnCwrCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpEcnCwrCounter defines model for Pattern.Flow.Tcp.EcnCwr.Counter.
type PatternFlowTcpEcnCwrCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpEcnEcho defines model for Pattern.Flow.Tcp.EcnEcho.
type PatternFlowTcpEcnEcho struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpEcnEchoCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpEcnEchoCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpEcnEchoCounter defines model for Pattern.Flow.Tcp.EcnEcho.Counter.
type PatternFlowTcpEcnEchoCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpEcnNs defines model for Pattern.Flow.Tcp.EcnNs.
type PatternFlowTcpEcnNs struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpEcnNsCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpEcnNsCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpEcnNsCounter defines model for Pattern.Flow.Tcp.EcnNs.Counter.
type PatternFlowTcpEcnNsCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpSeqNum defines model for Pattern.Flow.Tcp.SeqNum.
type PatternFlowTcpSeqNum struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpSeqNumCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpSeqNumCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpSeqNumCounter defines model for Pattern.Flow.Tcp.SeqNum.Counter.
type PatternFlowTcpSeqNumCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpSrcPort defines model for Pattern.Flow.Tcp.SrcPort.
type PatternFlowTcpSrcPort struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpSrcPortCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpSrcPortCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpSrcPortCounter defines model for Pattern.Flow.Tcp.SrcPort.Counter.
type PatternFlowTcpSrcPortCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowTcpWindow defines model for Pattern.Flow.Tcp.Window.
type PatternFlowTcpWindow struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowTcpWindowCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowTcpWindowCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowTcpWindowCounter defines model for Pattern.Flow.Tcp.Window.Counter.
type PatternFlowTcpWindowCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowUdpChecksum defines model for Pattern.Flow.Udp.Checksum.
type PatternFlowUdpChecksum struct {

	// The type of checksum
	Choice string `json:"choice"`

	// A custom checksum value
	Custom *int `json:"custom,omitempty"`

	// A system generated checksum value
	Generated *string `json:"generated,omitempty"`
}

// PatternFlowUdpDstPort defines model for Pattern.Flow.Udp.DstPort.
type PatternFlowUdpDstPort struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowUdpDstPortCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowUdpDstPortCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowUdpDstPortCounter defines model for Pattern.Flow.Udp.DstPort.Counter.
type PatternFlowUdpDstPortCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowUdpLength defines model for Pattern.Flow.Udp.Length.
type PatternFlowUdpLength struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowUdpLengthCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowUdpLengthCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowUdpLengthCounter defines model for Pattern.Flow.Udp.Length.Counter.
type PatternFlowUdpLengthCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowUdpSrcPort defines model for Pattern.Flow.Udp.SrcPort.
type PatternFlowUdpSrcPort struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowUdpSrcPortCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowUdpSrcPortCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowUdpSrcPortCounter defines model for Pattern.Flow.Udp.SrcPort.Counter.
type PatternFlowUdpSrcPortCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVlanCfi defines model for Pattern.Flow.Vlan.Cfi.
type PatternFlowVlanCfi struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVlanCfiCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVlanCfiCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVlanCfiCounter defines model for Pattern.Flow.Vlan.Cfi.Counter.
type PatternFlowVlanCfiCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVlanId defines model for Pattern.Flow.Vlan.Id.
type PatternFlowVlanId struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVlanIdCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVlanIdCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVlanIdCounter defines model for Pattern.Flow.Vlan.Id.Counter.
type PatternFlowVlanIdCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVlanPriority defines model for Pattern.Flow.Vlan.Priority.
type PatternFlowVlanPriority struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVlanPriorityCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVlanPriorityCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVlanPriorityCounter defines model for Pattern.Flow.Vlan.Priority.Counter.
type PatternFlowVlanPriorityCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVlanTpid defines model for Pattern.Flow.Vlan.Tpid.
type PatternFlowVlanTpid struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVlanTpidCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVlanTpidCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVlanTpidCounter defines model for Pattern.Flow.Vlan.Tpid.Counter.
type PatternFlowVlanTpidCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVxlanFlags defines model for Pattern.Flow.Vxlan.Flags.
type PatternFlowVxlanFlags struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVxlanFlagsCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVxlanFlagsCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVxlanFlagsCounter defines model for Pattern.Flow.Vxlan.Flags.Counter.
type PatternFlowVxlanFlagsCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVxlanReserved0 defines model for Pattern.Flow.Vxlan.Reserved0.
type PatternFlowVxlanReserved0 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVxlanReserved0Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVxlanReserved0Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVxlanReserved0Counter defines model for Pattern.Flow.Vxlan.Reserved0.Counter.
type PatternFlowVxlanReserved0Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVxlanReserved1 defines model for Pattern.Flow.Vxlan.Reserved1.
type PatternFlowVxlanReserved1 struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVxlanReserved1Counter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVxlanReserved1Counter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVxlanReserved1Counter defines model for Pattern.Flow.Vxlan.Reserved1.Counter.
type PatternFlowVxlanReserved1Counter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// PatternFlowVxlanVni defines model for Pattern.Flow.Vxlan.Vni.
type PatternFlowVxlanVni struct {
	Choice string `json:"choice"`

	// integer counter pattern
	Decrement *PatternFlowVxlanVniCounter `json:"decrement,omitempty"`

	// integer counter pattern
	Increment *PatternFlowVxlanVniCounter `json:"increment,omitempty"`

	// A unique name is used to indicate to the system that the field may extend the metric row key and create an aggregate metric row for every unique value. To have metric group columns appear in the flow metric rows the flow metric request allows for the metric_group value to be specified as part of the request.
	MetricGroup *string `json:"metric_group,omitempty"`
	Value       *int    `json:"value,omitempty"`
	Values      *[]int  `json:"values,omitempty"`
}

// PatternFlowVxlanVniCounter defines model for Pattern.Flow.Vxlan.Vni.Counter.
type PatternFlowVxlanVniCounter struct {
	Count *int `json:"count,omitempty"`
	Start int  `json:"start"`
	Step  int  `json:"step"`
}

// Port defines model for Port.
type Port struct {

	// The location of a test port.  It is the endpoint where packets will emit from.
	// Test port locations can be the following:
	//   - physical appliance with multiple ports
	//   - physical chassis with multiple cards and ports
	//   - local interface
	//   - virtual machine, docker container, kubernetes cluster
	//
	// The test port location format is implementation specific. Use the /results/capabilities API to determine what formats an  implementation supports for the location property.
	// Get the configured location state by using the /results/port API.
	Location *string `json:"location,omitempty"`

	// Globally unique name of an object. It also serves as the primary key for arrays of objects.
	Name string `json:"name"`
}

// PortMetric defines model for Port.Metric.
type PortMetric struct {

	// The current total number of valid bytes received
	BytesRx *int `json:"bytes_rx,omitempty"`

	// The current rate of bytes received
	BytesRxRate *float32 `json:"bytes_rx_rate,omitempty"`

	// The current total number of bytes transmitted
	BytesTx *int `json:"bytes_tx,omitempty"`

	// The current rate of bytes transmitted
	BytesTxRate *float32 `json:"bytes_tx_rate,omitempty"`

	// The state of the test port capture infrastructure. The string can be started, stopped or a custom error message.
	Capture *string `json:"capture,omitempty"`

	// The current total number of valid frames received
	FramesRx *int `json:"frames_rx,omitempty"`

	// The current rate of valid frames received
	FramesRxRate *float32 `json:"frames_rx_rate,omitempty"`

	// The current total number of frames transmitted
	FramesTx *int `json:"frames_tx,omitempty"`

	// The current rate of frames transmitted
	FramesTxRate *float32 `json:"frames_tx_rate,omitempty"`

	// The state of the test port link The string can be up, down or a custom error message.
	Link *string `json:"link,omitempty"`

	// The state of the connection to the test port location. The format should be the configured port location along with  any custom connection state message.
	Location *string `json:"location,omitempty"`

	// The name of a configured port
	Name *string `json:"name,omitempty"`
}

// PortMetricsRequest defines model for Port.Metrics.Request.
type PortMetricsRequest struct {

	// The list of column names that the returned result set will contain. If the list is empty then all columns will be returned. The name of the port cannot be excluded.
	ColumnNames *[]string `json:"column_names,omitempty"`

	// The names of objects to return results for. An empty list will return all port row results.
	PortNames *[]string `json:"port_names,omitempty"`
}

// PortOptions defines model for Port.Options.
type PortOptions struct {

	// Preempt all the test port locations as defined by the  Port.Port.properties.location. If the test ports defined by their location values are in use and  this value is true, the test ports will be preempted.
	LocationPreemption *bool `json:"location_preemption,omitempty"`
}

// PortState defines model for Port.State.
type PortState struct {
	Capture *string `json:"capture,omitempty"`
	Link    *string `json:"link,omitempty"`
	Name    *string `json:"name,omitempty"`
}

// ResponseError defines model for Response.Error.
type ResponseError struct {

	// A list of any system specific errors that have occurred while
	// executing the request.
	Errors *[]string `json:"errors,omitempty"`
}

// ResponseWarning defines model for Response.Warning.
type ResponseWarning struct {

	// A list of any system specific warnings that have occurred while
	// executing the request.
	Warnings *[]string `json:"warnings,omitempty"`
}

// StateMetrics defines model for State.Metrics.
type StateMetrics struct {
	FlowState *[]FlowState `json:"flow_state,omitempty"`
	PortState *[]PortState `json:"port_state,omitempty"`
}

// TransmitState defines model for Transmit.State.
type TransmitState struct {

	// The names of flows to which the transmit state will be applied to. If the list of flow_names is empty or null the state will be applied to all configured flows.
	FlowNames *[]string `json:"flow_names,omitempty"`

	// The transmit state.
	State string `json:"state"`
}

// BadRequest defines model for BadRequest.
type BadRequest ResponseError

// InternalServerError defines model for InternalServerError.
type InternalServerError ResponseError

// Success defines model for Success.
type Success ResponseWarning

// UpdateConfigJSONBody defines parameters for UpdateConfig.
type UpdateConfigJSONBody Config

// SetConfigJSONBody defines parameters for SetConfig.
type SetConfigJSONBody Config

// SetCaptureStateJSONBody defines parameters for SetCaptureState.
type SetCaptureStateJSONBody CaptureState

// SetLinkStateJSONBody defines parameters for SetLinkState.
type SetLinkStateJSONBody LinkState

// SetTransmitStateJSONBody defines parameters for SetTransmitState.
type SetTransmitStateJSONBody TransmitState

// GetCaptureJSONBody defines parameters for GetCapture.
type GetCaptureJSONBody CaptureRequest

// GetMetricsJSONBody defines parameters for GetMetrics.
type GetMetricsJSONBody MetricsRequest

// UpdateConfigRequestBody defines body for UpdateConfig for application/json ContentType.
type UpdateConfigJSONRequestBody UpdateConfigJSONBody

// SetConfigRequestBody defines body for SetConfig for application/json ContentType.
type SetConfigJSONRequestBody SetConfigJSONBody

// SetCaptureStateRequestBody defines body for SetCaptureState for application/json ContentType.
type SetCaptureStateJSONRequestBody SetCaptureStateJSONBody

// SetLinkStateRequestBody defines body for SetLinkState for application/json ContentType.
type SetLinkStateJSONRequestBody SetLinkStateJSONBody

// SetTransmitStateRequestBody defines body for SetTransmitState for application/json ContentType.
type SetTransmitStateJSONRequestBody SetTransmitStateJSONBody

// GetCaptureRequestBody defines body for GetCapture for application/json ContentType.
type GetCaptureJSONRequestBody GetCaptureJSONBody

// GetMetricsRequestBody defines body for GetMetrics for application/json ContentType.
type GetMetricsJSONRequestBody GetMetricsJSONBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A callback for modifying requests which are generated before sending over
	// the network.
	RequestEditor RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = http.DefaultClient
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditor = fn
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConfig request
	GetConfig(ctx context.Context) (*http.Response, error)

	// UpdateConfig request  with any body
	UpdateConfigWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	UpdateConfig(ctx context.Context, body UpdateConfigJSONRequestBody) (*http.Response, error)

	// SetConfig request  with any body
	SetConfigWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SetConfig(ctx context.Context, body SetConfigJSONRequestBody) (*http.Response, error)

	// SetCaptureState request  with any body
	SetCaptureStateWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SetCaptureState(ctx context.Context, body SetCaptureStateJSONRequestBody) (*http.Response, error)

	// SetLinkState request  with any body
	SetLinkStateWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SetLinkState(ctx context.Context, body SetLinkStateJSONRequestBody) (*http.Response, error)

	// SetTransmitState request  with any body
	SetTransmitStateWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	SetTransmitState(ctx context.Context, body SetTransmitStateJSONRequestBody) (*http.Response, error)

	// GetCapabilities request
	GetCapabilities(ctx context.Context) (*http.Response, error)

	// GetCapture request  with any body
	GetCaptureWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetCapture(ctx context.Context, body GetCaptureJSONRequestBody) (*http.Response, error)

	// GetMetrics request  with any body
	GetMetricsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error)

	GetMetrics(ctx context.Context, body GetMetricsJSONRequestBody) (*http.Response, error)

	// GetStateMetrics request
	GetStateMetrics(ctx context.Context) (*http.Response, error)
}

func (c *Client) GetConfig(ctx context.Context) (*http.Response, error) {
	req, err := NewGetConfigRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfigWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewUpdateConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateConfig(ctx context.Context, body UpdateConfigJSONRequestBody) (*http.Response, error) {
	req, err := NewUpdateConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfigWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetConfigRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetConfig(ctx context.Context, body SetConfigJSONRequestBody) (*http.Response, error) {
	req, err := NewSetConfigRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetCaptureStateWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetCaptureStateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetCaptureState(ctx context.Context, body SetCaptureStateJSONRequestBody) (*http.Response, error) {
	req, err := NewSetCaptureStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetLinkStateWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetLinkStateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetLinkState(ctx context.Context, body SetLinkStateJSONRequestBody) (*http.Response, error) {
	req, err := NewSetLinkStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetTransmitStateWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewSetTransmitStateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) SetTransmitState(ctx context.Context, body SetTransmitStateJSONRequestBody) (*http.Response, error) {
	req, err := NewSetTransmitStateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapabilities(ctx context.Context) (*http.Response, error) {
	req, err := NewGetCapabilitiesRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCaptureWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetCaptureRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetCapture(ctx context.Context, body GetCaptureJSONRequestBody) (*http.Response, error) {
	req, err := NewGetCaptureRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetricsWithBody(ctx context.Context, contentType string, body io.Reader) (*http.Response, error) {
	req, err := NewGetMetricsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetMetrics(ctx context.Context, body GetMetricsJSONRequestBody) (*http.Response, error) {
	req, err := NewGetMetricsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

func (c *Client) GetStateMetrics(ctx context.Context) (*http.Response, error) {
	req, err := NewGetStateMetricsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if c.RequestEditor != nil {
		err = c.RequestEditor(ctx, req)
		if err != nil {
			return nil, err
		}
	}
	return c.Client.Do(req)
}

// NewGetConfigRequest generates requests for GetConfig
func NewGetConfigRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/config")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUpdateConfigRequest calls the generic UpdateConfig builder with application/json body
func NewUpdateConfigRequest(server string, body UpdateConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateConfigRequestWithBody generates requests for UpdateConfig with any type of body
func NewUpdateConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/config")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PATCH", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewSetConfigRequest calls the generic SetConfig builder with application/json body
func NewSetConfigRequest(server string, body SetConfigJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetConfigRequestWithBody(server, "application/json", bodyReader)
}

// NewSetConfigRequestWithBody generates requests for SetConfig with any type of body
func NewSetConfigRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/config")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewSetCaptureStateRequest calls the generic SetCaptureState builder with application/json body
func NewSetCaptureStateRequest(server string, body SetCaptureStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetCaptureStateRequestWithBody(server, "application/json", bodyReader)
}

// NewSetCaptureStateRequestWithBody generates requests for SetCaptureState with any type of body
func NewSetCaptureStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/control/capture")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewSetLinkStateRequest calls the generic SetLinkState builder with application/json body
func NewSetLinkStateRequest(server string, body SetLinkStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetLinkStateRequestWithBody(server, "application/json", bodyReader)
}

// NewSetLinkStateRequestWithBody generates requests for SetLinkState with any type of body
func NewSetLinkStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/control/link")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewSetTransmitStateRequest calls the generic SetTransmitState builder with application/json body
func NewSetTransmitStateRequest(server string, body SetTransmitStateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetTransmitStateRequestWithBody(server, "application/json", bodyReader)
}

// NewSetTransmitStateRequestWithBody generates requests for SetTransmitState with any type of body
func NewSetTransmitStateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/control/transmit")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetCapabilitiesRequest generates requests for GetCapabilities
func NewGetCapabilitiesRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/results/capabilities")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCaptureRequest calls the generic GetCapture builder with application/json body
func NewGetCaptureRequest(server string, body GetCaptureJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetCaptureRequestWithBody(server, "application/json", bodyReader)
}

// NewGetCaptureRequestWithBody generates requests for GetCapture with any type of body
func NewGetCaptureRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/results/capture")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetMetricsRequest calls the generic GetMetrics builder with application/json body
func NewGetMetricsRequest(server string, body GetMetricsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewGetMetricsRequestWithBody(server, "application/json", bodyReader)
}

// NewGetMetricsRequestWithBody generates requests for GetMetrics with any type of body
func NewGetMetricsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/results/metrics")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)
	return req, nil
}

// NewGetStateMetricsRequest generates requests for GetStateMetrics
func NewGetStateMetricsRequest(server string) (*http.Request, error) {
	var err error

	queryUrl, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	basePath := fmt.Sprintf("/results/state")
	if basePath[0] == '/' {
		basePath = basePath[1:]
	}

	queryUrl, err = queryUrl.Parse(basePath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryUrl.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConfig request
	GetConfigWithResponse(ctx context.Context) (*GetConfigResponse, error)

	// UpdateConfig request  with any body
	UpdateConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*UpdateConfigResponse, error)

	UpdateConfigWithResponse(ctx context.Context, body UpdateConfigJSONRequestBody) (*UpdateConfigResponse, error)

	// SetConfig request  with any body
	SetConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetConfigResponse, error)

	SetConfigWithResponse(ctx context.Context, body SetConfigJSONRequestBody) (*SetConfigResponse, error)

	// SetCaptureState request  with any body
	SetCaptureStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetCaptureStateResponse, error)

	SetCaptureStateWithResponse(ctx context.Context, body SetCaptureStateJSONRequestBody) (*SetCaptureStateResponse, error)

	// SetLinkState request  with any body
	SetLinkStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetLinkStateResponse, error)

	SetLinkStateWithResponse(ctx context.Context, body SetLinkStateJSONRequestBody) (*SetLinkStateResponse, error)

	// SetTransmitState request  with any body
	SetTransmitStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetTransmitStateResponse, error)

	SetTransmitStateWithResponse(ctx context.Context, body SetTransmitStateJSONRequestBody) (*SetTransmitStateResponse, error)

	// GetCapabilities request
	GetCapabilitiesWithResponse(ctx context.Context) (*GetCapabilitiesResponse, error)

	// GetCapture request  with any body
	GetCaptureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetCaptureResponse, error)

	GetCaptureWithResponse(ctx context.Context, body GetCaptureJSONRequestBody) (*GetCaptureResponse, error)

	// GetMetrics request  with any body
	GetMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetMetricsResponse, error)

	GetMetricsWithResponse(ctx context.Context, body GetMetricsJSONRequestBody) (*GetMetricsResponse, error)

	// GetStateMetrics request
	GetStateMetricsWithResponse(ctx context.Context) (*GetStateMetricsResponse, error)
}

type GetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Config
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r GetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseWarning
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r UpdateConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetConfigResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseWarning
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r SetConfigResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetConfigResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetCaptureStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseWarning
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r SetCaptureStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetCaptureStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetLinkStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseWarning
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r SetLinkStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetLinkStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetTransmitStateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ResponseWarning
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r SetTransmitStateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetTransmitStateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCapabilitiesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Capabilities
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r GetCapabilitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCapabilitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCaptureResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r GetCaptureResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCaptureResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MetricsResponse
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r GetMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStateMetricsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *StateMetrics
	JSON400      *ResponseError
	JSON500      *ResponseError
}

// Status returns HTTPResponse.Status
func (r GetStateMetricsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStateMetricsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConfigWithResponse request returning *GetConfigResponse
func (c *ClientWithResponses) GetConfigWithResponse(ctx context.Context) (*GetConfigResponse, error) {
	rsp, err := c.GetConfig(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetConfigResponse(rsp)
}

// UpdateConfigWithBodyWithResponse request with arbitrary body returning *UpdateConfigResponse
func (c *ClientWithResponses) UpdateConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfigWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

func (c *ClientWithResponses) UpdateConfigWithResponse(ctx context.Context, body UpdateConfigJSONRequestBody) (*UpdateConfigResponse, error) {
	rsp, err := c.UpdateConfig(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseUpdateConfigResponse(rsp)
}

// SetConfigWithBodyWithResponse request with arbitrary body returning *SetConfigResponse
func (c *ClientWithResponses) SetConfigWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetConfigResponse, error) {
	rsp, err := c.SetConfigWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigResponse(rsp)
}

func (c *ClientWithResponses) SetConfigWithResponse(ctx context.Context, body SetConfigJSONRequestBody) (*SetConfigResponse, error) {
	rsp, err := c.SetConfig(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSetConfigResponse(rsp)
}

// SetCaptureStateWithBodyWithResponse request with arbitrary body returning *SetCaptureStateResponse
func (c *ClientWithResponses) SetCaptureStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetCaptureStateResponse, error) {
	rsp, err := c.SetCaptureStateWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetCaptureStateResponse(rsp)
}

func (c *ClientWithResponses) SetCaptureStateWithResponse(ctx context.Context, body SetCaptureStateJSONRequestBody) (*SetCaptureStateResponse, error) {
	rsp, err := c.SetCaptureState(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSetCaptureStateResponse(rsp)
}

// SetLinkStateWithBodyWithResponse request with arbitrary body returning *SetLinkStateResponse
func (c *ClientWithResponses) SetLinkStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetLinkStateResponse, error) {
	rsp, err := c.SetLinkStateWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetLinkStateResponse(rsp)
}

func (c *ClientWithResponses) SetLinkStateWithResponse(ctx context.Context, body SetLinkStateJSONRequestBody) (*SetLinkStateResponse, error) {
	rsp, err := c.SetLinkState(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSetLinkStateResponse(rsp)
}

// SetTransmitStateWithBodyWithResponse request with arbitrary body returning *SetTransmitStateResponse
func (c *ClientWithResponses) SetTransmitStateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*SetTransmitStateResponse, error) {
	rsp, err := c.SetTransmitStateWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseSetTransmitStateResponse(rsp)
}

func (c *ClientWithResponses) SetTransmitStateWithResponse(ctx context.Context, body SetTransmitStateJSONRequestBody) (*SetTransmitStateResponse, error) {
	rsp, err := c.SetTransmitState(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseSetTransmitStateResponse(rsp)
}

// GetCapabilitiesWithResponse request returning *GetCapabilitiesResponse
func (c *ClientWithResponses) GetCapabilitiesWithResponse(ctx context.Context) (*GetCapabilitiesResponse, error) {
	rsp, err := c.GetCapabilities(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetCapabilitiesResponse(rsp)
}

// GetCaptureWithBodyWithResponse request with arbitrary body returning *GetCaptureResponse
func (c *ClientWithResponses) GetCaptureWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetCaptureResponse, error) {
	rsp, err := c.GetCaptureWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureResponse(rsp)
}

func (c *ClientWithResponses) GetCaptureWithResponse(ctx context.Context, body GetCaptureJSONRequestBody) (*GetCaptureResponse, error) {
	rsp, err := c.GetCapture(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetCaptureResponse(rsp)
}

// GetMetricsWithBodyWithResponse request with arbitrary body returning *GetMetricsResponse
func (c *ClientWithResponses) GetMetricsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetricsWithBody(ctx, contentType, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

func (c *ClientWithResponses) GetMetricsWithResponse(ctx context.Context, body GetMetricsJSONRequestBody) (*GetMetricsResponse, error) {
	rsp, err := c.GetMetrics(ctx, body)
	if err != nil {
		return nil, err
	}
	return ParseGetMetricsResponse(rsp)
}

// GetStateMetricsWithResponse request returning *GetStateMetricsResponse
func (c *ClientWithResponses) GetStateMetricsWithResponse(ctx context.Context) (*GetStateMetricsResponse, error) {
	rsp, err := c.GetStateMetrics(ctx)
	if err != nil {
		return nil, err
	}
	return ParseGetStateMetricsResponse(rsp)
}

// ParseGetConfigResponse parses an HTTP response from a GetConfigWithResponse call
func ParseGetConfigResponse(rsp *http.Response) (*GetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Config
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseUpdateConfigResponse parses an HTTP response from a UpdateConfigWithResponse call
func ParseUpdateConfigResponse(rsp *http.Response) (*UpdateConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &UpdateConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetConfigResponse parses an HTTP response from a SetConfigWithResponse call
func ParseSetConfigResponse(rsp *http.Response) (*SetConfigResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetConfigResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetCaptureStateResponse parses an HTTP response from a SetCaptureStateWithResponse call
func ParseSetCaptureStateResponse(rsp *http.Response) (*SetCaptureStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetCaptureStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetLinkStateResponse parses an HTTP response from a SetLinkStateWithResponse call
func ParseSetLinkStateResponse(rsp *http.Response) (*SetLinkStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetLinkStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseSetTransmitStateResponse parses an HTTP response from a SetTransmitStateWithResponse call
func ParseSetTransmitStateResponse(rsp *http.Response) (*SetTransmitStateResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &SetTransmitStateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ResponseWarning
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCapabilitiesResponse parses an HTTP response from a GetCapabilitiesWithResponse call
func ParseGetCapabilitiesResponse(rsp *http.Response) (*GetCapabilitiesResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCapabilitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Capabilities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetCaptureResponse parses an HTTP response from a GetCaptureWithResponse call
func ParseGetCaptureResponse(rsp *http.Response) (*GetCaptureResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetCaptureResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetMetricsResponse parses an HTTP response from a GetMetricsWithResponse call
func ParseGetMetricsResponse(rsp *http.Response) (*GetMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MetricsResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}

// ParseGetStateMetricsResponse parses an HTTP response from a GetStateMetricsWithResponse call
func ParseGetStateMetricsResponse(rsp *http.Response) (*GetStateMetricsResponse, error) {
	bodyBytes, err := ioutil.ReadAll(rsp.Body)
	defer rsp.Body.Close()
	if err != nil {
		return nil, err
	}

	response := &GetStateMetricsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest StateMetrics
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 500:
		var dest ResponseError
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON500 = &dest

	}

	return response, nil
}
